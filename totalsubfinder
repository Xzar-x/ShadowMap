#!/bin/bash

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color - przywrócono standardowy kod

# Default configuration
URL=""
DOMAINS_FILE=""
WORDLIST="/usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt"
THREADS=40
TIMEOUT=30
# Added new tools to the list
TOOLS=("FFUF Subdomain" "Gobuster Vhost" "Subfinder" "Amass (long scan)" "Waybackurls" "Katana" "Hakrawler" "Paramspider")
# Domyślne włączenie wszystkich kluczowych narzędzi enumeracji subdomen
SELECTED=(1 1 1 1 1 1 1 1) # All selected by default

# Amass options
AMASS_PASSIVE=1
AMASS_BRUTE=0
AMASS_ACTIVE=0

# Global silent mode (0 = off, 1 = on)
SILENT_MODE=0

# Error log file
ERROR_LOG="totalsubfinder_error.log"

# Function to strip ANSI escape codes for length calculation
strip_ansi_codes() {
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

# ASCII Art
print_title() {
  clear
  cat <<\EOF
  ______      __        _______       __    _______           __         
 /_  __/___  / /_____ _/ / ___/__  __/ /_  / ____(_)___  ____/ /__  _____
  / / / __ \/ __/ __ `/ /\__ \/ / / / __ \/ /_  / / __ \/ __  / _ \/ ___/
 / / / /_/ / /_/ /_/ / /___/ / /_/ / /_/ / __/ / / / / / /_/ /  __/ /    
/_/  \____/\__/\__,_/_//____/\__,_/_.___/_/   /_/_/_/_/\__,_/\___/_/     
EOF
    echo -e "${NC}"
    echo -e "${BLUE}TotalSubFinder${NC} - Automated Reconnaissance Toolkit        ${GREEN}Made by Xzar${NC}\n"
}

# Function to return redirection string based on SILENT_MODE
# Przekierowanie błędów zawsze do ERROR_LOG
get_redirection_string() {
    if [ $SILENT_MODE -eq 1 ]; then
        echo ">/dev/null 2>> \"$ERROR_LOG\"" # Redirect stdout to null, stderr to error log
    else
        echo "2>> \"$ERROR_LOG\"" # Redirect stderr to error log
    fi
}

# Function to display a spinner animation in the background
# It takes the PIDs of the processes to monitor and the message
start_spinner() {
    if [ $SILENT_MODE -eq 1 ]; then
        return # Do not show spinner in silent mode
    fi
    local msg="$1" # First argument is the message
    shift # Remove message from arguments, remaining are PIDs
    local pids_to_monitor=("$@") # Get all remaining arguments as an array

    ( # Run spinner in a subshell
        local spin='-\|/'
        local i=0
        local all_done=0
        while [ "$all_done" -eq 0 ]; do
            all_done=1
            for pid in "${pids_to_monitor[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then # Check if PID is still running
                    all_done=0
                    break
                fi
            done
            i=$(( (i+1) % 4 ))
            echo -ne "\r${YELLOW}${spin:$i:1} ${msg}...${NC}"
            sleep 0.1
        done
        echo -ne "\r${GREEN}✓ ${msg} zakończony!${NC}\n"
    ) &
    echo $! # Return the PID of the spinner subshell
}


# Check dependencies
check_dependencies() {
    local missing=0
    # Dodano 'httpx' do listy narzędzi do sprawdzenia, upewnij się, że jest zainstalowany.
    local tools=("ffuf" "gobuster" "subfinder" "amass" "httpx" "jq" "waybackurls" "katana" "hakrawler") 
    
    echo -e "${BLUE}Checking dependencies...${NC}"
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            echo -e "${RED}Missing: $tool${NC}" >&2
            missing=1
        else
            echo -e "${GREEN}Found: $tool${NC}"
        fi
    done

    # Lepsze sprawdzanie paramspidera
    if ! command -v "paramspider" &> /dev/null; then 
        echo -e "${RED}Missing: paramspider (ensure it's installed and in your PATH, e.g., /usr/local/bin/paramspider. Try 'pip install paramspider' or 'git clone https://github.com/0xasm0d3us/ParamSpider.git' and add to PATH.)${NC}" >&2
        missing=1
    else
        echo -e "${GREEN}Found: paramspider${NC}"
    fi
    
    if [ $missing -eq 1 ]; then
        echo -e "\n${RED}Missing required tools. Please install them before continuing.${NC}" >&2
        echo "Check $ERROR_LOG for details." # Informacja o pliku logu
        exit 1
    fi
}

# Main menu
show_menu() {
    clear # Clear screen once at the beginning of the menu
    while true; do
        print_title
        echo -e "${YELLOW}Wybierz narzędzia: [1-${#TOOLS[@]}] przełącz główne narzędzia, [a/b/d] przełącz opcje Amass, ENTER aby kontynuować${NC}"
        
        # Display tools in two columns
        local num_tools=${#TOOLS[@]}
        local half_num=$(( (num_tools + 1) / 2 )) # Round up for the first column
        local col_width=35 # Ustaw szerokość kolumny dla lepszego dopasowania

        for ((i=0; i<half_num; i++)); do
            local left_status_char=$( [ ${SELECTED[i]} -eq 1 ] && echo "✓" || echo "✗" )
            local left_color=$( [ ${SELECTED[i]} -eq 1 ] && echo "${GREEN}" || echo "${RED}" )
            
            # Pełny tekst z kodami ANSI
            local left_full_text="  ${left_color}[$(($i+1))] ${left_status_char} ${TOOLS[i]}${NC}"
            # Tekst bez kodów ANSI do obliczenia długości
            local left_display_text="  [$(($i+1))] ${left_status_char} ${TOOLS[i]}"
            
            local right_full_text=""
            local right_index=$((i + half_num))
            if [ $right_index -lt $num_tools ]; then
                local right_status_char=$( [ ${SELECTED[right_index]} -eq 1 ] && echo "✓" || echo "✗" )
                local right_color=$( [ ${SELECTED[right_index]} -eq 1 ] && echo "${GREEN}" || echo "${RED}" )
                right_full_text="  ${right_color}[$(($right_index+1))] ${right_status_char} ${TOOLS[right_index]}${NC}"
            fi
            
            # Obliczanie wypełnienia na podstawie widocznej długości tekstu
            local left_len=$(echo "$left_display_text" | wc -c) # Używamy wc -c dla długości w znakach
            local padding=$(( col_width - left_len ))
            if [ $padding -lt 1 ]; then padding=1; fi # Zapewnij co najmniej jedną spację

            # Wyświetl wiersz, stosując kolory i wypełnienie
            echo -e "${left_full_text}$(printf '%*s' "$padding" "")${right_full_text}"
        done

        # Amass options (more compact, on one line)
        if [ ${SELECTED[3]} -eq 1 ]; then
            local passive_status=$( [ $AMASS_PASSIVE -eq 1 ] && echo -e "${GREEN}wł." || echo -e "${RED}wył." )
            local brute_status=$( [ $AMASS_BRUTE -eq 1 ] && echo -e "${GREEN}wł." || echo -e "${RED}wył." )
            local active_status=$( [ $AMASS_ACTIVE -eq 1 ] && echo -e "${GREEN}wł." || echo -e "${RED}wył." )
            echo -e "  ${BLUE}Amass: ${YELLOW}[a]${BLUE}Passive:${passive_status} ${YELLOW}[b]${BLUE}Brute:${brute_status} ${YELLOW}[d]${BLUE}Active:${active_status}${NC}"
        else
            echo -e "  (Opcje Amass wyłączone)"
        fi

        echo -e "${BLUE}Aktualne ustawienia:${NC}"
        # Display settings on fewer lines
        local domain_display="${URL:-$DOMAINS_FILE}"
        echo -e "  Domena: ${GREEN}${domain_display}${NC}"
        echo -e "  Lista słów: ${GREEN}${WORDLIST}${NC}"
        echo -e "  Wątki: ${GREEN}${THREADS}${NC}, Limit czasu: ${GREEN}${TIMEOUT}s${NC}"
        
        if [ $SILENT_MODE -eq 1 ]; then
            echo -e "  ${GREEN}[s] Tryb cichy: włączony${NC}"
        else
            echo -e "  ${NC}${RED}[s] Tryb cichy: wyłączony${NC}"
        fi
        
        echo -e "Naciśnij 1-${#TOOLS[@]} aby przełączyć narzędzia, a/b/d dla opcji Amass, ENTER aby rozpocząć"

        read -sn1 key
        [[ -z "$key" ]] && break
        
        if [[ "$key" =~ ^[0-9]+$ ]] && [ "$key" -ge 1 ] && [ "$key" -le "${#TOOLS[@]}" ]; then
            index=$((key-1))
            SELECTED[$index]=$((1 - SELECTED[$index]))
        elif [[ "$key" == "a" && ${SELECTED[3]} -eq 1 ]]; then
            AMASS_PASSIVE=$((1 - AMASS_PASSIVE))
        elif [[ "$key" == "b" && ${SELECTED[3]} -eq 1 ]]; then
            AMASS_BRUTE=$((1 - AMASS_BRUTE))
        elif [[ "$key" == "s" ]]; then
            SILENT_MODE=$((1 - SILENT_MODE))
        elif [[ "$key" == "d" && ${SELECTED[3]} -eq 1 ]]; then
            AMASS_ACTIVE=$((1 - AMASS_ACTIVE))
        fi
        clear # Clear screen before re-drawing the menu in the next iteration
    done
}

# Domain validation
is_valid_domain() {
    local domain_regex='^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$'
    [[ $1 =~ $domain_regex ]]
}

clean_domain() {
    echo "$1" | sed -e 's|^[^/]*//||' -e 's|/.*$||' -e 's/^www\.//'
}

scan_domain() {
    local domain=$1
    echo -e "\n${BLUE}Skanowanie: ${GREEN}$domain${NC}"
    
    # Split domain and port
    local domain_part=$(echo "$domain" | cut -d':' -f1)
    local port_part=$(echo "$domain" | grep -q ':' && echo "$domain" | cut -d':' -f2 || echo "")
    
    # Temporary files (using mktemp for unique names)
    local waybackurls_out=$(mktemp --suffix=".txt" waybackurls_"$domain_part".XXXXXX)
    local katana_out=$(mktemp --suffix=".txt" katana_"$domain_part".XXXXXX)
    local hakrawler_out=$(mktemp --suffix=".txt" hakrawler_"$domain_part".XXXXXX)
    local paramspider_out=$(mktemp --suffix=".txt" paramspider_"$domain_part".XXXXXX)

    # Temporary files for consolidation
    local all_subdomains_tmp=$(mktemp --suffix=".txt" all_subdomains_tmp.XXXXXX)
    local found_urls_tmp=$(mktemp --suffix=".txt" found_urls_tmp.XXXXXX)
    local urls_with_params_tmp=$(mktemp --suffix=".txt" urls_with_params_tmp.XXXXXX)
    local vhost_status_200_tmp=$(mktemp --suffix=".txt" vhost_status_200_tmp.XXXXXX)


    # Ensure temporary files are cleaned up on exit
    trap "rm -f \"$waybackurls_out\" \"$katana_out\" \"$hakrawler_out\" \"$paramspider_out\" \"$all_subdomains_tmp\" \"$found_urls_tmp\" \"$urls_with_params_tmp\" \"$vhost_status_200_tmp\"" EXIT

    local pids_stage1=() # PIDs for subdomain enumeration tools
    local pids_stage2=() # PIDs for crawling/parameter finding tools

    local redir_output_val=$(get_redirection_string) # Get redirection string once

    # --- Etap 1: Enumeracja subdomen ---
    echo -e "${BLUE}Rozpoczynam etap 1: Enumeracja subdomen...${NC}"

    # FFUF Subdomain
    if [ ${SELECTED[0]} -eq 1 ]; then
        (
            echo -e "${BLUE}[+] FFUF Subdomain${NC}"
            protocol="https://"
            [ -n "$port_part" ] && protocol="http://"
            # Przekierowanie wyjścia FFUF bezpośrednio do all_subdomains_tmp
            if eval "ffuf -u \"${protocol}FUZZ.$domain_part\" -w \"$WORDLIST\" -ic -t $THREADS -o /dev/stdout $redir_output_val | grep -Eo \"([a-zA-Z0-9-]+\.)+$domain_part\" | sed 's|^http[s]*://||' | sort -u >> \"$all_subdomains_tmp\""; then
                true # Success
            else
                echo -e "${RED}Błąd podczas uruchamiania FFUF!${NC}" >&2
            fi
        ) &
        pids_stage1+=($!)
    fi

    # Gobuster Vhost
    if [ ${SELECTED[1]} -eq 1 ]; then
        (
            echo -e "${BLUE}[+] Gobuster Vhost${NC}"
            # Przekierowanie wyjścia Gobuster bezpośrednio do all_subdomains_tmp i vhost_status_200_tmp
            if eval "gobuster vhost -u \"http://$domain\" --append-domain -w \"$WORDLIST\" -t $THREADS $redir_output_val | tee >(grep \"Found:\" | grep -i \"status: 200\" | cut -d' ' -f2 | sort -u >> \"$vhost_status_200_tmp\") | grep \"Found:\" | cut -d' ' -f2 | sort -u >> \"$all_subdomains_tmp\""; then
                true # Success
            else
                echo -e "${RED}Błąd podczas uruchamiania Gobuster!${NC}" >&2
            fi
        ) &
        pids_stage1+=($!)
    fi

    # Subfinder
    if [ ${SELECTED[2]} -eq 1 ]; then
        (
            echo -e "${BLUE}[+] Subfinder${NC}"
            # Przekierowanie wyjścia Subfinder bezpośrednio do all_subdomains_tmp
            if eval "subfinder -d \"$domain_part\" -silent $redir_output_val >> \"$all_subdomains_tmp\""; then
                true # Success
            else
                echo -e "${RED}Błąd podczas uruchamiania Subfinder!${NC}" >&2
            fi
        ) &
        pids_stage1+=($!)
    fi

    # Amass
    if [ ${SELECTED[3]} -eq 1 ]; then
        (
            echo -e "${BLUE}[+] Amass${NC}"
            amass_opts=()
            # Ensure at least one Amass option is selected if Amass is enabled
            if [ $AMASS_PASSIVE -eq 0 ] && [ $AMASS_BRUTE -eq 0 ] && [ $AMASS_ACTIVE -eq 0 ]; then
                AMASS_PASSIVE=1 # Default to passive if none selected
            fi
            
            [ $AMASS_PASSIVE -eq 1 ] && amass_opts+=("-passive")
            [ $AMASS_BRUTE -eq 1 ] && amass_opts+=("-brute")
            [ $AMASS_ACTIVE -eq 1 ] && amass_opts+=("-active")
            
            # Amass configuration file is crucial for API keys
            # Przekierowanie wyjścia Amass bezpośrednio do all_subdomains_tmp
            if eval "amass enum \"${amass_opts[@]}\" -d \"$domain_part\" -json /dev/stdout --config \"$HOME/.config/amass/config.yaml\" $redir_output_val | jq -r '.name' | sort -u >> \"$all_subdomains_tmp\""; then
                true # Success
            else
                echo -e "${RED}Błąd podczas uruchamiania Amass! Sprawdź konfigurację API kluczy.${NC}" >&2
            fi
        ) &
        pids_stage1+=($!)
    fi

    # Waybackurls
    if [ ${SELECTED[4]} -eq 1 ]; then
        (
            echo -e "${BLUE}[+] Waybackurls${NC}"
            if eval "waybackurls \"$domain_part\" $redir_output_val > \"$waybackurls_out\""; then
                cat "$waybackurls_out" >> "$found_urls_tmp"
            else
                echo -e "${RED}Błąd podczas uruchamiania Waybackurls!${NC}" >&2
            fi
        ) &
        pids_stage1+=($!)
    fi

    # Wait for all Stage 1 processes to finish
    if [ ${#pids_stage1[@]} -gt 0 ]; then
        spinner_pid=$(start_spinner "Etap 1: Enumeracja subdomen" "${pids_stage1[@]}")
        for pid in "${pids_stage1[@]}"; do
            wait "$pid" || true
        done
        kill "$spinner_pid" 2>/dev/null
    fi

    # Consolidate all_subdomains.txt and find live hosts after Stage 1
    echo -e "\n${BLUE}Finalizuję etap 1 i sprawdzam żywe hosty...${NC}"
    # First, consolidate all_subdomains.txt from temporary files
    if [ -f "$all_subdomains_tmp" ]; then
        sort -u "$all_subdomains_tmp" -o all_subdomains.txt
    else
        touch all_subdomains.txt
    fi

    # Consolidate found_urls.txt from temporary files
    if [ -f "$found_urls_tmp" ]; then
        sort -u "$found_urls_tmp" -o found_urls.txt
    else
        touch found_urls.txt
    fi

    # Consolidate vhost_status_200.txt from temporary files
    if [ -f "$vhost_status_200_tmp" ]; then
        sort -u "$vhost_status_200_tmp" -o vhost_status_200.txt
    else
        touch vhost_status_200.txt
    fi

    echo -e "${BLUE}Unikalne subdomeny po etapie 1: ${GREEN}$(wc -l < all_subdomains.txt)${NC}"
    echo -e "${BLUE}Sprawdzam żywe hosty...${NC}"
    # Ensure httpx runs and creates live_subdomains.txt before Stage 2 tools
    if [ "$(wc -l < all_subdomains.txt)" -gt 0 ]; then
        (
            # Użycie -silent w httpx, aby nie zaśmiecać wyjścia, jeśli nie jest w trybie cichym
            if eval "httpx -l all_subdomains.txt -silent -threads $THREADS -timeout $TIMEOUT -o live_subdomains.txt $redir_output_val"; then
                true # Success
            else
                echo -e "${RED}Błąd podczas uruchamiania httpx! Nie udało się znaleźć żywych hostów.${NC}" >&2
                false # Failure
            fi
        ) &
        httpx_pid=$!
        spinner_pid=$(start_spinner "Sprawdzanie żywych hostów" "$httpx_pid")
        if ! wait "$httpx_pid"; then # Poprawiono htt_pid na httpx_pid
            touch live_subdomains.txt
        fi
        kill "$spinner_pid" 2>/dev/null
    else
        echo -e "${YELLOW}Brak subdomen do sprawdzenia za pomocą httpx. Tworzenie pustego pliku live_subdomains.txt.${NC}"
        touch live_subdomains.txt
    fi
    echo -e "${Blue}Żywe hosty: ${GREEN}$(wc -l < live_subdomains.txt)${NC}"


    # --- Etap 2: Crawling i wyszukiwanie parametrów (wymaga żywych hostów) ---
    echo -e "\n${BLUE}Rozpoczynam etap 2: Crawling i wyszukiwanie parametrów...${NC}"

    # Katana
    if [ ${SELECTED[5]} -eq 1 ]; then
        (
            echo -e "${BLUE}[+] Katana${NC}"
            if [ -f "live_subdomains.txt" ] && [ "$(wc -l < live_subdomains.txt)" -gt 0 ]; then
                if eval "cat live_subdomains.txt | xargs -I {} -P $THREADS katana -u {} -o \"$katana_out\" -silent $redir_output_val"; then
                    # Add to final all_subdomains.txt and found_urls.txt
                    grep -Eo "([a-zA-Z0-9-]+\.)+$domain_part" "$katana_out" | sort -u >> all_subdomains.txt
                    cat "$katana_out" >> found_urls.txt
                else
                    echo -e "${RED}Błąd podczas uruchamiania Katana!${NC}" >&2
                fi
            else
                echo -e "${YELLOW}Brak żywych hostów do skanowania Katana lub plik live_subdomains.txt jest pusty.${NC}"
            fi
        ) &
        pids_stage2+=($!)
    fi

    # Hakrawler
    if [ ${SELECTED[6]} -eq 1 ]; then
        (
            echo -e "${BLUE}[+] Hakrawler${NC}"
            if [ -f "live_subdomains.txt" ] && [ "$(wc -l < live_subdomains.txt)" -gt 0 ]; then
                if eval "cat live_subdomains.txt | xargs -I {} -P $THREADS echo {} | hakrawler $redir_output_val > \"$hakrawler_out\""; then
                    # Add to final all_subdomains.txt and found_urls.txt
                    grep -Eo "([a-zA-Z0-9-]+\.)+$domain_part" "$hakrawler_out" | sort -u >> all_subdomains.txt
                    cat "$hakrawler_out" >> found_urls.txt
                else
                    echo -e "${RED}Błąd podczas uruchamiania Hakrawler!${NC}" >&2
                fi
            else
                echo -e "${YELLOW}Brak żywych hostów do skanowania Hakrawler lub plik live_subdomains.txt jest pusty.${NC}"
            fi
        ) &
        pids_stage2+=($!)
    fi

    # Paramspider
    if [ ${SELECTED[7]} -eq 1 ]; then
        (
            echo -e "${BLUE}[+] Paramspider${NC}"
            # Usunięto problematyczne argumenty. Paramspider zazwyczaj wypisuje wyniki na stdout.
            # Sprawdź `paramspider --help` dla dokładnych opcji w twojej wersji.
            # Zamiast `--output \"$paramspider_out\" -q`, użyj przekierowania stdout.
            if eval "paramspider -d \"$domain_part\" $redir_output_val > \"$paramspider_out\""; then
                if [ -s "$paramspider_out" ]; then # Sprawdź, czy plik nie jest pusty
                    # Paramspider domyślnie wypisuje URL-e.
                    cat "$paramspider_out" | sort -u >> "$urls_with_params_tmp"
                    # Add subdomains found by paramspider to all_subdomains.txt
                    grep -Eo "([a-zA-Z0-9-]+\.)+$domain_part" "$urls_with_params_tmp" | sort -u >> all_subdomains.txt
                else
                    echo -e "${YELLOW}Ostrzeżenie: Plik wyjściowy Paramspider ($paramspider_out) jest pusty lub nie został utworzony poprawnie.${NC}" >&2
                fi
            else
                echo -e "${RED}Błąd podczas uruchamiania Paramspider! Upewnij się, że jest zainstalowany i dostępny w PATH. Sprawdź logi Paramspider, jeśli występują błędy.${NC}" >&2
            fi
        ) &
        pids_stage2+=($!)
    fi

    # Wait for all Stage 2 processes to finish
    if [ ${#pids_stage2[@]} -gt 0 ]; then
        spinner_pid=$(start_spinner "Etap 2: Crawling i parametry" "${pids_stage2[@]}")
        for pid in "${pids_stage2[@]}"; do
            wait "$pid" || true
        done
        kill "$spinner_pid" 2>/dev/null
    fi

    # Consolidate urls_with_params.txt from temporary files
    if [ -f "$urls_with_params_tmp" ]; then
        sort -u "$urls_with_params_tmp" -o urls_with_params.txt
    else
        touch urls_with_params.txt
    fi

    echo -ne "\r${GREEN}✓ Skanowanie zakończone!${NC}\n"

    # Temporary files are cleaned up by the trap command on script exit
}

main() {
    # Usuń stary log błędów i wszystkie pliki wyjściowe na początku
    rm -f all_subdomains.txt live_subdomains.txt report.md vhost_status_200.txt found_urls.txt urls_with_params.txt "$ERROR_LOG"
    # Upewnij się, że wszystkie pliki wyjściowe istnieją i są puste na początku, nawet jeśli nie zostaną użyte
    touch all_subdomains.txt live_subdomains.txt found_urls.txt urls_with_params.txt vhost_status_200.txt "$ERROR_LOG"

    # Parse command-line options
    while getopts "u:f:w:t:T:hS" opt; do
        case $opt in
            u) URL=$(clean_domain "$OPTARG") ;;
            f) DOMAINS_FILE="$OPTARG" ;;
            w) WORDLIST="$OPTARG" ;;
            t) THREADS="$OPTARG" ;;
            T) TIMEOUT="$OPTARG" ;;
            h) 
                echo "Usage: $0 [-u URL] [-f FILE] [-w WORDLIST] [-t THREADS] [-T TIMEOUT] [-S]"
                echo "  -u URL       Target URL (e.g., example.com)"
                echo "  -f FILE      File containing list of domains"
                echo "  -w WORDLIST  Path to wordlist file (default: /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt)"
                echo "  -t THREADS   Number of threads (default: 40)"
                echo "  -T TIMEOUT   Timeout in seconds (default: 30)"
                echo "  -S           Enable silent mode (suppress tool output)"
                exit 0
                ;;
            S) SILENT_MODE=1 ;;
            *) 
                echo -e "${RED}Invalid option: -$OPTARG${NC}" >&2
                echo "Usage: $0 [-u URL] [-f FILE] [-t THREADS] [-T TIMEOUT] [-S]" >&2
                exit 1
                ;;
        esac
    done

    # Walidacja
    [ -z "$URL" ] && [ -z "$DOMAINS_FILE" ] && { echo -e "${RED}Error: Provide domain (-u) or domains file (-f)${NC}" >&2; exit 1; }
    [ -n "$DOMAINS_FILE" ] && [ ! -f "$DOMAINS_FILE" ] && { echo -e "${RED}Error: Domains file not found: $DOMAINS_FILE${NC}" >&2; exit 1; }

    check_dependencies
    show_menu

    # Przetwarzanie celów
    if [ -n "$DOMAINS_FILE" ]; then
        while IFS= read -r domain || [ -n "$domain" ]; do
            domain=$(clean_domain "$domain")
            is_valid_domain "$domain" && scan_domain "$domain"
        done < "$DOMAINS_FILE"
    else
        scan_domain "$URL"
    fi

    # Final consolidation and sorting of main output files
    sort -u all_subdomains.txt -o all_subdomains.txt
    sort -u found_urls.txt -o found_urls.txt
    sort -u urls_with_params.txt -o urls_with_params.txt
    sort -u vhost_status_200.txt -o vhost_status_200.txt
    sort -u live_subdomains.txt -o live_subdomains.txt


    echo -e "\n${BLUE}Unikalne subdomeny: ${GREEN}$(wc -l < all_subdomains.txt)${NC}"
    if [ ${SELECTED[1]} -eq 1 ] && [ -f "vhost_status_200.txt" ]; then
        echo -e "${BLUE}Vhosty ze statusem 200: ${GREEN}$(wc -l < vhost_status_200.txt)${NC}"
    fi
    echo -e "${GREEN}Żywe hosty: $(wc -l < live_subdomains.txt)${NC}"
    echo -e "${BLUE}Wszystkie znalezione URL-e (Waybackurls, Katana, Hakrawler): ${GREEN}$(wc -l < found_urls.txt)${NC}"
    echo -e "${BLUE}URL-e z parametrami (Paramspider): ${GREEN}$(wc -l < urls_with_params.txt)${NC}"


    # Generowanie raportu
    {
        echo "# Raport Subdomen"
        echo "**Data**: $(date)"
        echo "**Cel(e)**: ${URL:-$DOMAINS_FILE}"
        echo "**Użyte narzędzia**:"
        [ ${SELECTED[0]} -eq 1 ] && echo "- FFUF"
        [ ${SELECTED[1]} -eq 1 ] && echo "- Gobuster"
        [ ${SELECTED[2]} -eq 1 ] && echo "- Subfinder"
        [ ${SELECTED[3]} -eq 1 ] && echo "- Amass"
        [ ${SELECTED[4]} -eq 1 ] && echo "- Waybackurls"
        [ ${SELECTED[5]} -eq 1 ] && echo "- Katana"
        [ ${SELECTED[6]} -eq 1 ] && echo "- Hakrawler"
        [ ${SELECTED[7]} -eq 1 ] && echo "- Paramspider"
        echo "## Wyniki"
        echo "### Wszystkie subdomeny"
        cat all_subdomains.txt | wc -l
        echo "### Żywe hosty"
        cat live_subdomains.txt | wc -l
        if [ ${SELECTED[1]} -eq 1 ] && [ -f "vhost_status_200.txt" ]; then
            echo "### Vhosty ze statusem 200"
            cat vhost_status_200.txt | wc -l
        fi
        if [ ${SELECTED[4]} -eq 1 ] || [ ${SELECTED[5]} -eq 1 ] || [ ${SELECTED[6]} -eq 1 ]; then
            echo "### Wszystkie znalezione URL-e"
            cat found_urls.txt | wc -l
        fi
        if [ ${SELECTED[7]} -eq 1 ]; then
            echo "### URL-e z parametrami"
            cat urls_with_params.txt | wc -l
        fi
        
        # Dodanie sekcji błędów do raportu
        if [ -s "$ERROR_LOG" ]; then # Tylko jeśli plik nie jest pusty
            echo "## Logi błędów"
            echo "Poniżej znajdują się błędy napotkane podczas działania narzędzi. Proszę sprawdzić plik '$ERROR_LOG' dla pełnych szczegółów."
            echo "\`\`\`"
            cat "$ERROR_LOG"
            echo "\`\`\`"
        fi

    } > report.md

    echo -e "\n${GREEN}Raport zapisany: report.md${NC}"
    echo -e "${BLUE}Wyniki:${NC}"
    echo -e "• Wszystkie subdomeny: all_subdomains.txt"
    echo -e "• Żywe hosty: live_subdomains.txt"
    if [ ${SELECTED[1]} -eq 1 ] && [ -f "vhost_status_200.txt" ]; then
        echo -e "• Vhosty: vhost_status_200.txt"
    fi
    if [ ${SELECTED[4]} -eq 1 ] || [ ${SELECTED[5]} -eq 1 ] || [ ${SELECTED[6]} -eq 1 ]; then
        echo -e "• Wszystkie znalezione URL-e: found_urls.txt"
    fi
    if [ ${SELECTED[7]} -eq 1 ]; then
        echo -e "• URL-e z parametrami: urls_with_params.txt"
    fi
    echo -e "• Logi błędów: $ERROR_LOG"
}

main "$@"
