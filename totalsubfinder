#!/bin/bash

# Kolory
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # Brak koloru - przywrócono standardowy kod

# Domyślna konfiguracja
URL=""
DOMAINS_FILE=""
WORDLIST="/usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt"
THREADS=40
TIMEOUT=30

# Nowe globalne zmienne dla limitowania zapytań i trybu stealth
RATE_LIMIT_MODE="MEDIUM" # Domyślny tryb limitowania zapytań
CUSTOM_RATE_LIMIT=""    # Jeśli użytkownik poda konkretną liczbę
STEALTH_MODE=0          # 0 = wyłączony, 1 = włączony

# Domyślne opóźnienie i User-Agent dla trybu stealth
DEFAULT_DELAY=1         # Domyślne opóźnienie w sekundach
DEFAULT_RANDOM_UA=1     # 1 = używaj losowego User-Agenta

# Zdefiniowanie narzędzi i ich nazw do wyświetlania w menu
TOOLS=(
    "FFUF Subdomain"
    "Gobuster Vhost"
    "Subfinder"
    "Amass (long scan)"
    "Waybackurls"
    "Katana"
    "Hakrawler"
    "Paramspider"
    "CRT.sh" # Nowe narzędzie
)

# Domyślne włączenie wszystkich kluczowych narzędzi enumeracji subdomen
SELECTED=(1 1 1 1 1 1 1 1 1) # Wszystkie wybrane domyślnie

# Opcje Amass
AMASS_PASSIVE=1
AMASS_BRUTE=0
AMASS_ACTIVE=0

# Globalny tryb cichy (0 = wyłączony, 1 = włączony)
SILENT_MODE=0

# Plik logu błędów
ERROR_LOG="totalsubfinder_error.log"

# Opcje wyjścia
JSON_OUTPUT=0
OUTPUT_DIR="" # Domyślny katalog wyjściowy to bieżący

# Tymczasowy katalog (ustawiany w main)
TMPDIR=""

# Globalna zmienna dla opcji Amass, aby była dostępna w run_tool
amass_opts_str=""

# Deklaracja tablicy asocjacyjnej dla komend narzędzi
# Komendy będą modyfikowane w zależności od trybu limitowania zapytań
declare -A TOOL_CMDS=(
  ["FFUF Subdomain"]="ffuf -u 'https://FUZZ.\$domain_part' -w '\$WORDLIST' -ic -t \$THREADS" # Komenda bazowa, protokół będzie zmieniany dynamicznie
  ["Gobuster Vhost"]="gobuster vhost -u 'http://\$domain' --append-domain -w '\$WORDLIST' -t \$THREADS"
  ["Subfinder"]="subfinder -d '\$domain_part' -silent"
  ["Amass (long scan)"]="amass enum \$amass_opts_str -d '\$domain_part' -json /dev/stdout --config '\$HOME/.config/amass/config.yaml'"
  ["Waybackurls"]="waybackurls '\$domain_part'"
  ["Katana"]="katana -silent" # Katana będzie używać stdin z live_subdomains.tmp
  ["Hakrawler"]="hakrawler" # Hakrawler będzie używać stdin z live_subdomains.tmp
  ["Paramspider"]="paramspider -d '\$domain_part'"
  ["CRT.sh"]="curl -s 'https://crt.sh/?q=%25.\$domain_part&output=json' | jq -r '.[].common_name' | sed 's/^\*\.//g' | sort -u"
)

# Funkcja do usuwania kodów ANSI escape dla obliczania długości
strip_ansi_codes() {
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

# Funkcja do ustawiania opcji limitowania zapytań dla narzędzi
apply_rate_limit_options() {
    local tool_name="$1"
    local base_cmd="${TOOL_CMDS[$tool_name]}"
    local modified_cmd="$base_cmd"
    local delay_opt=""
    local user_agent_opt=""

    # Losowy User-Agent, jeśli włączony tryb stealth
    if [ "$STEALTH_MODE" -eq 1 ] || [ "$DEFAULT_RANDOM_UA" -eq 1 ]; then
        # Lista popularnych User-Agentów
        local user_agents=(
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0"
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:102.0) Gecko/20100101 Firefox/102.0"
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
            "Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Mobile/15E148 Safari/604.1"
            "Mozilla/5.0 (iPad; CPU OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Mobile/15E148 Safari/604.1"
        )
        user_agent_opt="-H \"User-Agent: ${user_agents[$RANDOM % ${#user_agents[@]}]}\""
    fi

    local current_threads="$THREADS"
    local current_delay=0

    # Ustawianie limitów w zależności od trybu
    case "$RATE_LIMIT_MODE" in
        "LOW")
            current_threads=5 # Bardzo niskie wątki
            current_delay=$DEFAULT_DELAY # Domyślne opóźnienie
            ;;
        "MEDIUM")
            current_threads=20 # Średnie wątki
            current_delay=0.5 # Mniejsze opóźnienie
            ;;
        "HIGH")
            current_threads=40 # Wysokie wątki (domyślne)
            current_delay=0 # Brak opóźnienia
            ;;
        *) # Niestandardowa liczba wątków
            if [[ "$CUSTOM_RATE_LIMIT" =~ ^[0-9]+$ ]]; then
                current_threads="$CUSTOM_RATE_LIMIT"
                current_delay=0 # Brak opóźnienia przy niestandardowym limicie (zakładamy, że użytkownik wie, co robi)
            fi
            ;;
    esac

    # Nadpisanie ustawień, jeśli włączony tryb stealth
    if [ "$STEALTH_MODE" -eq 1 ]; then
        current_threads=1 # Bardzo niska liczba wątków
        current_delay=2   # Większe opóźnienie
    fi

    # Dodawanie opcji do komend narzędzi
    case "$tool_name" in
        "FFUF Subdomain")
            modified_cmd=$(echo "$base_cmd" | sed "s/-t \$THREADS/-t $current_threads/g")
            if [ "$current_delay" -gt 0 ]; then
                modified_cmd+=" -delay ${current_delay}s"
            fi
            if [ -n "$user_agent_opt" ]; then
                modified_cmd+=" $user_agent_opt"
            fi
            ;;
        "Gobuster Vhost")
            modified_cmd=$(echo "$base_cmd" | sed "s/-t \$THREADS/-t $current_threads/g")
            if [ "$current_delay" -gt 0 ]; then
                modified_cmd+=" -d ${current_delay}s" # Gobuster używa -d dla opóźnienia
            fi
            if [ -n "$user_agent_opt" ]; then
                modified_cmd+=" -H \"User-Agent: $(echo "$user_agent_opt" | sed 's/-H "User-Agent: //;s/"$//')\""
            fi
            ;;
        "Subfinder")
            # Subfinder ma wbudowane mechanizmy, ale możemy ograniczyć liczbę wątków
            modified_cmd=$(echo "$base_cmd" | sed "s/-silent/-silent -t $current_threads/g")
            # Subfinder nie ma bezpośredniej opcji opóźnienia per zapytanie, ale można użyć -rl dla ogólnego limitu
            # Nie dodajemy -rl tutaj, aby nie kolidować z jego wewnętrzną logiką, chyba że jest to konieczne
            # Jeśli potrzebne, można dodać: modified_cmd+=" -rl $current_threads"
            if [ -n "$user_agent_opt" ]; then
                # Subfinder nie ma bezpośredniej flagi UA, ale można ją dodać do jego konfiguracji lub użyć proxy
                # Na potrzeby tego skryptu, pomijamy UA dla subfindera, chyba że jest to kluczowe
                true # Brak bezpośredniego wsparcia UA w CLI dla subfindera
            fi
            ;;
        "Amass (long scan)")
            # Amass ma własne mechanizmy limitowania i User-Agentów w pliku konfiguracyjnym
            # Tutaj możemy ewentualnie ograniczyć liczbę aktywnych zapytań, jeśli tryb jest LOW
            if [ "$RATE_LIMIT_MODE" == "LOW" ] || [ "$STEALTH_MODE" -eq 1 ]; then
                # Można zmodyfikować plik konfiguracyjny Amass dynamicznie, ale to jest bardziej złożone.
                # Na razie pomijamy bezpośrednie sterowanie Amass przez te flagi,
                # polegając na jego wewnętrznych mechanizmach i pliku config.yaml
                true
            fi
            ;;
        "Waybackurls")
            # Waybackurls nie ma bezpośrednich opcji limitowania ani UA w CLI
            # Można użyć curl z opcjami, jeśli Waybackurls jest wywoływany przez curl
            if [[ "$base_cmd" == *"curl"* ]]; then
                if [ "$current_delay" -gt 0 ]; then
                    modified_cmd=$(echo "$base_cmd" | sed "s|curl -s|curl -s --max-time ${TIMEOUT} --connect-timeout ${TIMEOUT} --retry 3 --retry-delay ${current_delay}|g")
                fi
                if [ -n "$user_agent_opt" ]; then
                    modified_cmd=$(echo "$modified_cmd" | sed "s|curl -s|curl -s $user_agent_opt|g")
                fi
            fi
            ;;
        "Katana")
            # Katana ma opcje -c (concurrency) i -d (delay)
            modified_cmd=$(echo "$base_cmd" | sed "s/-silent/-silent -c $current_threads/g")
            if [ "$current_delay" -gt 0 ]; then
                modified_cmd+=" -delay ${current_delay}s"
            fi
            if [ -n "$user_agent_opt" ]; then
                modified_cmd+=" -H \"User-Agent: $(echo "$user_agent_opt" | sed 's/-H "User-Agent: //;s/"$//')\""
            fi
            ;;
        "Hakrawler")
            # Hakrawler ma opcje -t (threads) i -d (delay)
            modified_cmd=$(echo "$base_cmd" | sed "s|hakrawler|hakrawler -t $current_threads|g")
            if [ "$current_delay" -gt 0 ]; then
                modified_cmd+=" -d ${current_delay}s"
            fi
            if [ -n "$user_agent_opt" ]; then
                modified_cmd+=" -ua \"$(echo "$user_agent_opt" | sed 's/-H "User-Agent: //;s/"$//')\""
            fi
            ;;
        "Paramspider")
            # Paramspider nie ma bezpośrednich opcji limitowania ani UA w CLI
            # Bazuje na wbudowanym mechanizmie requests, można by modyfikować jego kod źródłowy
            # Na potrzeby tego skryptu, pomijamy bezpośrednie sterowanie
            true
            ;;
        "CRT.sh")
            # CRT.sh używa curl, więc możemy dodać opóźnienie i UA
            if [[ "$base_cmd" == *"curl"* ]]; then
                if [ "$current_delay" -gt 0 ]; then
                    modified_cmd=$(echo "$base_cmd" | sed "s|curl -s|curl -s --max-time ${TIMEOUT} --connect-timeout ${TIMEOUT} --retry 3 --retry-delay ${current_delay}|g")
                fi
                if [ -n "$user_agent_opt" ]; then
                    modified_cmd=$(echo "$modified_cmd" | sed "s|curl -s|curl -s $user_agent_opt|g")
                fi
            fi
            ;;
        *)
            # Domyślne zachowanie dla nieznanych narzędzi
            ;;
    esac
    echo "$modified_cmd"
}


# ASCII Art
print_title() {
  clear
  cat <<\EOF
  ______      __        _______       __    _______           __         
 /_  __/___  / /_____ _/ / ___/__  __/ /_  / ____(_)___  ____/ /__  _____
  / / / __ \/ __/ __ `/ /\__ \/ / / / __ \/ /_  / / __ \/ __  / _ \/ ___/
 / / / /_/ / /_/ /_/ / /___/ / /_/ / /_/ / __/ / / / / / /_/ /  __/ /    
/_/  \____/\__/\__,_/_//____/\__,_/_.___/_/   /_/_/_/_/\__,_/\___/_/     
EOF
    echo -e "${NC}"
    echo -e "${BLUE}TotalSubFinder${NC} - Automated Reconnaissance Toolkit        ${GREEN}Made by Xzar${NC}\n"
}

# Funkcja zwracająca ciąg przekierowania na podstawie SILENT_MODE
# Przekierowanie błędów zawsze do ERROR_LOG
get_redirection_string() {
    if [ $SILENT_MODE -eq 1 ]; then
        echo ">/dev/null 2>> \"$ERROR_LOG\"" # Przekieruj stdout do null, stderr do logu błędów
    else
        echo "2>> \"$ERROR_LOG\"" # Przekieruj stderr do logu błędów
    fi
}

# Funkcja do uruchamiania narzędzia i monitorowania go spinnerem
# Zwraca PID podpowłoki uruchamiającej narzędzie
run_tool() {
    local tool_name="$1"
    local cmd_template="$2"
    local output_file="$3" # Opcjonalnie: plik do przekierowania stdout
    local input_file="$4" # Opcjonalnie: plik wejściowy dla narzędzi (np. Katana, Hakrawler)

    # Zastosuj opcje limitowania zapytań do komendy
    local current_cmd=$(apply_rate_limit_options "$tool_name" "$cmd_template")

    # Zastąp zmienne w szablonie komendy
    # Zmienne takie jak $domain_part, $domain, $WORDLIST, $THREADS, $TIMEOUT, $amass_opts_str
    # muszą być dostępne w zasięgu wywołania run_tool.
    current_cmd="${current_cmd//\$domain_part/$domain_part}"
    current_cmd="${current_cmd//\$domain/$domain}"
    current_cmd="${current_cmd//\$WORDLIST/$WORDLIST}"
    current_cmd="${current_cmd//\$THREADS/$THREADS}" # THREADS tutaj może być nadpisane przez apply_rate_limit_options
    current_cmd="${current_cmd//\$TIMEOUT/$TIMEOUT}"
    current_cmd="${current_cmd//\$amass_opts_str/$amass_opts_str}"

    (
        # Użyj eval do wykonania komendy, z odpowiednimi przekierowaniami
        if [ -n "$input_file" ]; then
            if [ -n "$output_file" ]; then
                eval "cat \"$input_file\" | $current_cmd > \"$output_file\" $(get_redirection_string)"
            else
                eval "cat \"$input_file\" | $current_cmd $(get_redirection_string)"
            fi
        else
            if [ -n "$output_file" ]; then
                eval "$current_cmd > \"$output_file\" $(get_redirection_string)"
            else
                eval "$current_cmd $(get_redirection_string)"
            fi
        fi
    ) &
    echo $! # Zwróć PID podpowłoki uruchamiającej narzędzie
}

# Funkcja do wyświetlania animacji spinnera w tle
# Przyjmuje PIDy procesów do monitorowania i wiadomość
start_spinner() {
    if [ $SILENT_MODE -eq 1 ]; then
        return # Nie pokazuj spinnera w trybie cichym
    fi
    local msg="$1" # Pierwszy argument to wiadomość
    shift # Usuń wiadomość z argumentów, pozostałe to PIDy
    local pids_to_monitor=("$@") # Pobierz wszystkie pozostałe argumenty jako tablicę

    ( # Uruchom spinner w podpowłoce
        local spin='-\|/'
        local i=0
        local all_done=0
        local start_time=$(date +%s)
        local timeout_seconds=600 # Timeout spinnera po 10 minutach (600 sekund)

        while [ "$all_done" -eq 0 ]; do
            all_done=1
            for pid in "${pids_to_monitor[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then # Sprawdź, czy PID nadal działa
                    all_done=0
                    break
                fi
            done
            
            local current_time=$(date +%s)
            if (( current_time - start_time > timeout_seconds )); then
                echo -ne "\r${RED}✗ ${msg} przekroczył limit czasu (${timeout_seconds}s)!${NC}\n"
                # Zabij procesy, które przekroczyły limit czasu
                for pid in "${pids_to_monitor[@]}"; do
                    kill "$pid" 2>/dev/null
                done
                exit 1 # Wyjdź z podpowłoki spinnera
            fi

            i=$(( (i+1) % 4 ))
            echo -ne "\r${YELLOW}${spin:$i:1} ${msg}...${NC}"
            sleep 0.1
        done
        echo -ne "\r${GREEN}✓ ${msg} zakończony!${NC}\n"
    ) &
    echo $! # Zwróć PID podpowłoki spinnera
}


# Sprawdź zależności
check_dependencies() {
    local missing=0
    # Dodano 'httpx' i 'jq' do listy narzędzi do sprawdzenia
    local tools=("ffuf" "gobuster" "subfinder" "amass" "httpx" "jq" "waybackurls" "katana" "hakrawler" "curl") 
    
    echo -e "${BLUE}Sprawdzanie zależności...${NC}"
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            echo -e "${RED}Brak: $tool${NC}" >&2
            missing=1
        else
            echo -e "${GREEN}Znaleziono: $tool${NC}"
        fi
    done

    # Lepsze sprawdzanie paramspidera
    if ! command -v "paramspider" &> /dev/null; then 
        echo -e "${RED}Brak: paramspider (upewnij się, że jest zainstalowany i w twojej PATH, np. /usr/local/bin/paramspider. Spróbuj 'pip install paramspider' lub 'git clone https://github.com/0xasm0d3us/ParamSpider.git' i dodaj do PATH.)${NC}" >&2
        missing=1
    else
        echo -e "${GREEN}Znaleziono: paramspider${NC}"
    fi
    
    if [ $missing -eq 1 ]; then
        echo -e "\n${RED}Brak wymaganych narzędzi. Zainstaluj je przed kontynuowaniem.${NC}" >&2
        echo "Sprawdź $ERROR_LOG, aby uzyskać szczegóły." # Informacja o pliku logu
        exit 1
    fi
}

# Główne menu
show_menu() {
    clear # Wyczyść ekran raz na początku menu
    while true; do
        print_title
        echo -e "${YELLOW}Wybierz narzędzia: [1-${#TOOLS[@]}] przełącz główne narzędzia, [a/b/d] przełącz opcje Amass, ENTER aby kontynuować${NC}"
        
        # Wyświetl narzędzia w dwóch kolumnach
        local num_tools=${#TOOLS[@]}
        local half_num=$(( (num_tools + 1) / 2 )) # Zaokrąglaj w górę dla pierwszej kolumny
        local col_width=35 # Ustaw szerokość kolumny dla lepszego dopasowania

        for ((i=0; i<half_num; i++)); do
            local left_status_char=$( [ ${SELECTED[i]} -eq 1 ] && echo "✓" || echo "✗" )
            local left_color=$( [ ${SELECTED[i]} -eq 1 ] && echo "${GREEN}" || echo "${RED}" )
            
            # Pełny tekst z kodami ANSI
            local left_full_text="  ${left_color}[$(($i+1))] ${left_status_char} ${TOOLS[i]}${NC}"
            # Tekst bez kodów ANSI do obliczenia długości
            local left_display_text="  [$(($i+1))] ${left_status_char} ${TOOLS[i]}"
            
            local right_full_text=""
            local right_index=$((i + half_num))
            if [ $right_index -lt $num_tools ]; then
                local right_status_char=$( [ ${SELECTED[right_index]} -eq 1 ] && echo "✓" || echo "✗" )
                local right_color=$( [ ${SELECTED[right_index]} -eq 1 ] && echo "${GREEN}" || echo "${RED}" )
                right_full_text="  ${right_color}[$(($right_index+1))] ${right_status_char} ${TOOLS[right_index]}${NC}"
            fi
            
            # Obliczanie wypełnienia na podstawie widocznej długości tekstu
            local left_len=$(strip_ansi_codes "$left_full_text" | wc -c) # Używamy wc -c dla długości w znakach
            local padding=$(( col_width - left_len ))
            if [ $padding -lt 1 ]; then padding=1; fi # Zapewnij co najmniej jedną spację

            # Wyświetl wiersz, stosując kolory i wypełnienie
            echo -e "${left_full_text}$(printf '%*s' "$padding" "")${right_full_text}"
        done

        # Opcje Amass (bardziej kompaktowe, w jednej linii)
        if [ ${SELECTED[3]} -eq 1 ]; then
            local passive_status=$( [ $AMASS_PASSIVE -eq 1 ] && echo -e "${GREEN}wł." || echo -e "${RED}wył." )
            local brute_status=$( [ $AMASS_BRUTE -eq 1 ] && echo -e "${GREEN}wł." || echo -e "${RED}wył." )
            local active_status=$( [ $AMASS_ACTIVE -eq 1 ] && echo -e "${GREEN}wł." || echo -e "${RED}wył." )
            echo -e "  ${BLUE}Amass: ${YELLOW}[a]${BLUE}Passive:${passive_status} ${YELLOW}[b]${BLUE}Brute:${brute_status} ${YELLOW}[d]${BLUE}Active:${active_status}${NC}"
        else
            echo -e "  (Opcje Amass wyłączone)"
        fi

        echo -e "${BLUE}Aktualne ustawienia:${NC}"
        # Wyświetl ustawienia na mniejszej liczbie linii
        local domain_display="${URL:-$DOMAINS_FILE}"
        echo -e "  Domena: ${GREEN}${domain_display}${NC}"
        echo -e "  Lista słów: ${GREEN}${WORDLIST}${NC}"
        echo -e "  Wątki: ${GREEN}${THREADS}${NC}, Limit czasu: ${GREEN}${TIMEOUT}s${NC}"
        
        if [ $SILENT_MODE -eq 1 ]; then
            echo -e "  ${GREEN}[s] Tryb cichy: włączony${NC}"
        else
            echo -e "  ${NC}${RED}[s] Tryb cichy: wyłączony${NC}"
        fi

        # Wyświetlanie trybu limitowania zapytań
        local rl_display="$RATE_LIMIT_MODE"
        if [ -n "$CUSTOM_RATE_LIMIT" ]; then
            rl_display="$CUSTOM_RATE_LIMIT"
        fi
        echo -e "  ${BLUE}Limit zapytań (--rl): ${GREEN}${rl_display}${NC}"

        # Wyświetlanie trybu stealth
        if [ $STEALTH_MODE -eq 1 ]; then
            echo -e "  ${GREEN}[x] Tryb Stealth: włączony (LOW + opóźnienia + losowy UA)${NC}"
        else
            echo -e "  ${NC}${RED}[x] Tryb Stealth: wyłączony${NC}"
        fi

        if [ -n "$OUTPUT_DIR" ]; then
            echo -e "  ${BLUE}Katalog wyjściowy: ${GREEN}${OUTPUT_DIR}${NC}"
        fi
        if [ $JSON_OUTPUT -eq 1 ]; then
            echo -e "  ${BLUE}Wyjście JSON: ${GREEN}włączone${NC}"
        fi
        
        echo -e "Naciśnij 1-${#TOOLS[@]} aby przełączyć narzędzia, a/b/d dla opcji Amass, ENTER aby rozpocząć"

        read -sn1 key
        [[ -z "$key" ]] && break
        
        if [[ "$key" =~ ^[0-9]+$ ]] && [ "$key" -ge 1 ] && [ "$key" -le "${#TOOLS[@]}" ]; then
            index=$((key-1))
            SELECTED[$index]=$((1 - SELECTED[$index]))
        elif [[ "$key" == "a" && ${SELECTED[3]} -eq 1 ]]; then
            AMASS_PASSIVE=$((1 - AMASS_PASSIVE))
        elif [[ "$key" == "b" && ${SELECTED[3]} -eq 1 ]]; then
            AMASS_BRUTE=$((1 - AMASS_BRUTE))
        elif [[ "$key" == "s" ]]; then
            SILENT_MODE=$((1 - SILENT_MODE))
        elif [[ "$key" == "d" && ${SELECTED[3]} -eq 1 ]]; then
            AMASS_ACTIVE=$((1 - AMASS_ACTIVE))
        elif [[ "$key" == "x" ]]; then # Przełącznik dla trybu stealth
            STEALTH_MODE=$((1 - STEALTH_MODE))
            if [ "$STEALTH_MODE" -eq 1 ]; then
                RATE_LIMIT_MODE="LOW" # Ustawia limit na LOW
                CUSTOM_RATE_LIMIT=""
            else
                RATE_LIMIT_MODE="MEDIUM" # Przywraca domyślny, jeśli stealth wyłączony
            fi
        fi
        clear # Wyczyść ekran przed ponownym rysowaniem menu w następnej iteracji
    done
}

# Walidacja domeny
is_valid_domain() {
    local domain_regex='^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$'
    [[ $1 =~ $domain_regex ]]
}

clean_domain() {
    echo "$1" | sed -e 's|^[^/]*//||' -e 's|/.*$||' -e 's/^www\.//'
}

# Etap 1: Enumeracja subdomen
recon_stage() {
    local domain=$1
    local domain_part=$(echo "$domain" | cut -d':' -f1)
    local port_part=$(echo "$domain" | grep -q ':' && echo "$domain" | cut -d':' -f2 || echo "")

    echo -e "${BLUE}Rozpoczynam etap 1: Enumeracja subdomen dla ${GREEN}$domain${NC}"

    local pids_stage1=() # PIDs dla narzędzi enumeracji subdomen

    # Konfiguracja opcji Amass (musi być wykonana przed jakimkolwiek wywołaniem Amass)
    local amass_opts=()
    if [ $AMASS_PASSIVE -eq 0 ] && [ $AMASS_BRUTE -eq 0 ] && [ $AMASS_ACTIVE -eq 0 ]; then
        AMASS_PASSIVE=1
    fi
    [ $AMASS_PASSIVE -eq 1 ] && amass_opts+=("-passive")
    [ $AMASS_BRUTE -eq 1 ] && amass_opts+=("-brute")
    [ $AMASS_ACTIVE -eq 1 ] && amass_opts+=("-active")
    amass_opts_str="${amass_opts[@]}" # Ustaw zmienną globalną

    for i in "${!TOOLS[@]}"; do
        local tool_name="${TOOLS[$i]}"
        local cmd_template="${TOOL_CMDS[$tool_name]}"
        local output_file=""
        local input_file="" # Nieużywany w tym etapie, ale dla spójności

        if [ ${SELECTED[$i]} -eq 1 ]; then
            case "$tool_name" in
                "FFUF Subdomain")
                    echo -e "${BLUE}[+] FFUF Subdomain${NC}"
                    local protocol="https://"
                    [ -n "$port_part" ] && protocol="http://"
                    # Skonstruuj komendę FFUF dynamicznie ze względu na protokół
                    cmd_template="ffuf -u \"${protocol}FUZZ.$domain_part\" -w \"$WORDLIST\" -ic -t \$THREADS"
                    output_file="$TMPDIR/ffuf_subdomains.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                "Gobuster Vhost")
                    echo -e "${BLUE}[+] Gobuster Vhost${NC}"
                    output_file="$TMPDIR/gobuster_vhost.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                "Subfinder")
                    echo -e "${BLUE}[+] Subfinder${NC}"
                    output_file="$TMPDIR/subfinder_subdomains.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                "Amass (long scan)")
                    echo -e "${BLUE}[+] Amass${NC}"
                    output_file="$TMPDIR/amass_subdomains.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                "CRT.sh")
                    echo -e "${BLUE}[+] CRT.sh${NC}"
                    output_file="$TMPDIR/crtsh_subdomains.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                "Waybackurls")
                    echo -e "${BLUE}[+] Waybackurls${NC}"
                    output_file="$TMPDIR/waybackurls_out.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                *)
                    # Narzędzia niebędące częścią etapu recon, lub już obsłużone
                    ;;
            esac
        fi
    done

    # Poczekaj, aż wszystkie procesy Etapu 1 zakończą się
    if [ ${#pids_stage1[@]} -gt 0 ]; then
        spinner_pid=$(start_spinner "Etap 1: Enumeracja subdomen" "${pids_stage1[@]}")
        for pid in "${pids_stage1[@]}"; do
            wait "$pid" || true
        done
        kill "$spinner_pid" 2>/dev/null
    fi

    # Konsolidacja wszystkich subdomen i znalezienie żywych hostów po Etapie 1
    echo -e "\n${BLUE}Finalizuję etap 1 i sprawdzam żywe hosty...${NC}"

    # Skonsoliduj wszystkie tymczasowe pliki subdomen
    find "$TMPDIR" -name "*_subdomains.tmp" -exec cat {} + 2>/dev/null | sort -u > "$TMPDIR/all_subdomains.tmp"

    echo -e "${BLUE}Unikalne subdomeny po etapie 1: ${GREEN}$(wc -l < "$TMPDIR/all_subdomains.tmp" 2>/dev/null || echo 0)${NC}"
    echo -e "${BLUE}Sprawdzam żywe hosty...${NC}"
    
    # Upewnij się, że httpx działa i tworzy live_subdomains.tmp przed narzędziami Etapu 2
    if [ -s "$TMPDIR/all_subdomains.tmp" ]; then # Sprawdź, czy plik nie jest pusty
        (
            # Zastosuj opcje limitowania zapytań do httpx
            local httpx_cmd="httpx -l \"$TMPDIR/all_subdomains.tmp\" -silent -threads \$THREADS -timeout \$TIMEOUT"
            httpx_cmd=$(apply_rate_limit_options "httpx" "$httpx_cmd") # Użyj "httpx" jako nazwy narzędzia dla apply_rate_limit_options
            
            if eval "$httpx_cmd -o \"$TMPDIR/live_subdomains.tmp\" $(get_redirection_string)"; then
                true # Sukces
            else
                echo -e "${RED}Błąd podczas uruchamiania httpx! Nie udało się znaleźć żywych hostów.${NC}" >&2
                false # Niepowodzenie
            fi
        ) &
        httpx_pid=$!
        spinner_pid=$(start_spinner "Sprawdzanie żywych hostów" "$httpx_pid")
        if ! wait "$httpx_pid"; then
            touch "$TMPDIR/live_subdomains.tmp"
        fi
        kill "$spinner_pid" 2>/dev/null
    else
        echo -e "${YELLOW}Brak subdomen do sprawdzenia za pomocą httpx. Tworzenie pustego pliku live_subdomains.tmp.${NC}"
        touch "$TMPDIR/live_subdomains.tmp"
    fi
    echo -e "${BLUE}Żywe hosty: ${GREEN}$(wc -l < "$TMPDIR/live_subdomains.tmp" 2>/dev/null || echo 0)${NC}"
}

# Etap 2: Crawling i wyszukiwanie parametrów
crawl_stage() {
    local domain=$1
    local domain_part=$(echo "$domain" | cut -d':' -f1)

    echo -e "\n${BLUE}Rozpoczynam etap 2: Crawling i wyszukiwanie parametrów dla ${GREEN}$domain${NC}"

    local pids_stage2=() # PIDs dla narzędzi crawlingu/wyszukiwania parametrów

    for i in "${!TOOLS[@]}"; do
        local tool_name="${TOOLS[$i]}"
        local cmd_template="${TOOL_CMDS[$tool_name]}"
        local output_file=""
        local input_file=""

        if [ ${SELECTED[$i]} -eq 1 ]; then
            case "$tool_name" in
                "Katana")
                    echo -e "${BLUE}[+] Katana${NC}"
                    output_file="$TMPDIR/katana_out.tmp"
                    input_file="$TMPDIR/live_subdomains.tmp"
                    if [ ! -s "$input_file" ]; then
                        echo -e "${YELLOW}Brak żywych hostów do skanowania Katana lub plik live_subdomains.tmp jest pusty.${NC}"
                        continue # Pomiń to narzędzie, jeśli brak danych wejściowych
                    fi
                    pids_stage2+=($(run_tool "$tool_name" "$cmd_template" "$output_file" "$input_file"))
                    ;;
                "Hakrawler")
                    echo -e "${BLUE}[+] Hakrawler${NC}"
                    output_file="$TMPDIR/hakrawler_out.tmp"
                    input_file="$TMPDIR/live_subdomains.tmp"
                    if [ ! -s "$input_file" ]; then
                        echo -e "${YELLOW}Brak żywych hostów do skanowania Hakrawler lub plik live_subdomains.tmp jest pusty.${NC}"
                        continue # Pomiń to narzędzie, jeśli brak danych wejściowych
                    fi
                    pids_stage2+=($(run_tool "$tool_name" "$cmd_template" "$output_file" "$input_file"))
                    ;;
                "Paramspider")
                    echo -e "${BLUE}[+] Paramspider${NC}"
                    output_file="$TMPDIR/paramspider_out.tmp"
                    pids_stage2+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                *)
                    # Narzędzia niebędące częścią etapu crawlingu, lub już obsłużone
                    ;;
            esac
        fi
    done

    # Poczekaj, aż wszystkie procesy Etapu 2 zakończą się
    if [ ${#pids_stage2[@]} -gt 0 ]; then
        spinner_pid=$(start_spinner "Etap 2: Crawling i parametry" "${pids_stage2[@]}")
        for pid in "${pids_stage2[@]}"; do
            wait "$pid" || true
        done
        kill "$spinner_pid" 2>/dev/null
    fi

    echo -ne "\r${GREEN}✓ Skanowanie zakończone!${NC}\n"
}

# Główna funkcja skanowania domeny
scan_domain() {
    local domain=$1
    
    # Podziel domenę i port (zmienne globalne dla run_tool)
    domain_part=$(echo "$domain" | cut -d':' -f1)
    port_part=$(echo "$domain" | grep -q ':' && echo "$domain" | cut -d':' -f2 || echo "")

    # Uruchom etapy
    recon_stage "$domain"
    crawl_stage "$domain"

    # Konsolidacja wyników z plików tymczasowych do plików docelowych
    # Subdomeny
    cat "$TMPDIR/ffuf_subdomains.tmp" "$TMPDIR/gobuster_vhost.tmp" "$TMPDIR/subfinder_subdomains.tmp" "$TMPDIR/amass_subdomains.tmp" "$TMPDIR/crtsh_subdomains.tmp" 2>/dev/null | sort -u >> "$OUTPUT_DIR/all_subdomains.txt"
    
    # Żywe hosty
    if [ -f "$TMPDIR/live_subdomains.tmp" ]; then
        cat "$TMPDIR/live_subdomains.tmp" >> "$OUTPUT_DIR/live_subdomains.txt"
    fi

    # Vhosty ze statusem 200 (z Gobuster)
    if [ -f "$TMPDIR/gobuster_vhost.tmp" ]; then
        # Gobuster vhost output contains "Found: subdomain.example.com (Status: 200)"
        grep "Found:" "$TMPDIR/gobuster_vhost.tmp" | grep -i "status: 200" | cut -d' ' -f2 | sort -u >> "$OUTPUT_DIR/vhost_status_200.txt"
    fi

    # Znalezione URL-e (Waybackurls, Katana, Hakrawler)
    cat "$TMPDIR/waybackurls_out.tmp" "$TMPDIR/katana_out.tmp" "$TMPDIR/hakrawler_out.tmp" 2>/dev/null | sort -u >> "$OUTPUT_DIR/found_urls.txt"

    # URL-e z parametrami (Paramspider)
    if [ -f "$TMPDIR/paramspider_out.tmp" ]; then
        cat "$TMPDIR/paramspider_out.tmp" | sort -u >> "$OUTPUT_DIR/urls_with_params.txt"
    fi
}

# Funkcja do generowania raportu JSON
generate_json_report() {
    local domain_for_report=$1 # Użyj tej zmiennej, aby uniknąć kolizji nazw
    local report_file="$OUTPUT_DIR/report.json"

    local all_subdomains_count=$(wc -l < "$OUTPUT_DIR/all_subdomains.txt" 2>/dev/null || echo 0)
    local live_subdomains_count=$(wc -l < "$OUTPUT_DIR/live_subdomains.txt" 2>/dev/null || echo 0)
    local vhost_200_count=$(wc -l < "$OUTPUT_DIR/vhost_status_200.txt" 2>/dev/null || echo 0)
    local found_urls_count=$(wc -l < "$OUTPUT_DIR/found_urls.txt" 2>/dev/null || echo 0)
    local urls_with_params_count=$(wc -l < "$OUTPUT_DIR/urls_with_params.txt" 2>/dev/null || echo 0)

    local error_log_content=""
    if [ -s "$ERROR_LOG" ]; then
        # Wczytaj zawartość logu błędów i escapuj znaki specjalne dla JSON
        error_log_content=$(cat "$ERROR_LOG" | sed 's/"/\\"/g' | sed ':a;N;s/\n/\\n/g;ta')
    fi

    local selected_tools_json=""
    for i in "${!TOOLS[@]}"; do
        if [ ${SELECTED[i]} -eq 1 ]; then
            selected_tools_json+="\"${TOOLS[i]}\","
        fi
    done
    selected_tools_json="${selected_tools_json%,}" # Usuń ostatni przecinek

    cat <<EOF > "$report_file"
{
    "date": "$(date)",
    "target": "$domain_for_report",
    "used_tools": [${selected_tools_json}],
    "results": {
        "all_subdomains_count": $all_subdomains_count,
        "live_subdomains_count": $live_subdomains_count,
        "vhost_status_200_count": $vhost_200_count,
        "found_urls_count": $found_urls_count,
        "urls_with_params_count": $urls_with_params_count
    },
    "files": {
        "all_subdomains": "$(basename "$OUTPUT_DIR/all_subdomains.txt")",
        "live_subdomains": "$(basename "$OUTPUT_DIR/live_subdomains.txt")",
        "vhost_status_200": "$(basename "$OUTPUT_DIR/vhost_status_200.txt")",
        "found_urls": "$(basename "$OUTPUT_DIR/found_urls.txt")",
        "urls_with_params": "$(basename "$OUTPUT_DIR/urls_with_params.txt")",
        "error_log": "$(basename "$ERROR_LOG")"
    },
    "error_log_content": "$error_log_content"
}
EOF
    echo -e "\n${GREEN}Raport JSON zapisany: $report_file${NC}"
}


main() {
    # Usuń wszelkie pozostałe katalogi tymczasowe z poprzednich uruchomień
    rm -rf /tmp/totalsubfinder_* 2>/dev/null

    # Ustaw tymczasowy katalog i pułapkę na wyjście
    TMPDIR=$(mktemp -d -t totalsubfinder_XXXXXX)
    trap 'rm -rf "$TMPDIR"; echo -e "${BLUE}Wyczyszczono tymczasowy katalog: $TMPDIR${NC}"' EXIT

    # Domyślny katalog wyjściowy
    OUTPUT_DIR="./"

    # Usuń stary log błędów na początku
    rm -f "$ERROR_LOG"
    touch "$ERROR_LOG" # Upewnij się, że plik logu błędów istnieje

    # Parsowanie opcji wiersza poleceń
    # Dodano 'r' dla --rl i 'x' dla --stealth
    while getopts "u:f:w:t:T:hSjo:r:x" opt; do
        case $opt in
            u) URL=$(clean_domain "$OPTARG") ;;
            f) DOMAINS_FILE="$OPTARG" ;;
            w) WORDLIST="$OPTARG" ;;
            t) THREADS="$OPTARG" ;;
            T) TIMEOUT="$OPTARG" ;;
            h) 
                echo "Usage: $0 [-u URL] [-f FILE] [-w WORDLIST] [-t THREADS] [-T TIMEOUT] [-S] [-j] [-o OUTPUT_DIR] [--rl RATE_LIMIT_MODE] [--stealth]"
                echo "  -u URL         Docelowy URL (np. example.com)"
                echo "  -f FILE        Plik zawierający listę domen"
                echo "  -w WORDLIST    Ścieżka do pliku listy słów (domyślnie: /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt)"
                echo "  -t THREADS     Liczba wątków (domyślnie: 40)"
                echo "  -T TIMEOUT     Limit czasu w sekundach (domyślnie: 30)"
                echo "  -S             Włącz tryb cichy (pomija wyjście narzędzi)"
                echo "  -j             Generuj raport JSON"
                echo "  -o OUTPUT_DIR  Określ katalog wyjściowy"
                echo "  -r RATE_LIMIT_MODE Tryb limitowania zapytań: LOW|MEDIUM|HIGH|<liczba> (domyślnie: MEDIUM)"
                echo "  -x             Włącz tryb stealth (automatycznie ustawia --rl=LOW + opóźnienia + losowy User-Agent)"
                echo ""
                echo "Przykłady użycia:"
                echo "  $0 -u example.com"
                echo "  $0 -f domains.txt -j -o my_scan_results"
                echo "  $0 -u example.com --rl LOW"
                echo "  $0 -u example.com --stealth"
                exit 0
                ;;
            S) SILENT_MODE=1 ;;
            j) JSON_OUTPUT=1 ;;
            o) OUTPUT_DIR="$OPTARG"
               mkdir -p "$OUTPUT_DIR" || { echo -e "${RED}Błąd: Nie można utworzyć katalogu wyjściowego: $OUTPUT_DIR${NC}" >&2; exit 1; }
               ;;
            r) # Obsługa parametru --rl
                case "$OPTARG" in
                    "LOW"|"MEDIUM"|"HIGH")
                        RATE_LIMIT_MODE="$OPTARG"
                        CUSTOM_RATE_LIMIT="" # Resetuj niestandardowy limit
                        ;;
                    *)
                        if [[ "$OPTARG" =~ ^[0-9]+$ ]]; then
                            RATE_LIMIT_MODE="CUSTOM"
                            CUSTOM_RATE_LIMIT="$OPTARG"
                        else
                            echo -e "${RED}Nieprawidłowa wartość dla --rl: $OPTARG. Użyj LOW, MEDIUM, HIGH lub liczby.${NC}" >&2
                            exit 1
                        fi
                        ;;
                esac
                ;;
            x) # Obsługa parametru --stealth
                STEALTH_MODE=1
                RATE_LIMIT_MODE="LOW" # Tryb stealth wymusza LOW
                CUSTOM_RATE_LIMIT="" # Resetuj niestandardowy limit
                ;;
            *) 
                echo -e "${RED}Nieprawidłowa opcja: -$OPTARG${NC}" >&2
                echo "Usage: $0 [-u URL] [-f FILE] [-t THREADS] [-T TIMEOUT] [-S] [-j] [-o OUTPUT_DIR] [--rl RATE_LIMIT_MODE] [--stealth]" >&2
                exit 1
                ;;
        esac
    done

    # Walidacja
    [ -z "$URL" ] && [ -z "$DOMAINS_FILE" ] && { echo -e "${RED}Błąd: Podaj domenę (-u) lub plik domen (-f)${NC}" >&2; exit 1; }
    [ -n "$DOMAINS_FILE" ] && [ ! -f "$DOMAINS_FILE" ] && { echo -e "${RED}Błąd: Plik domen nie znaleziono: $DOMAINS_FILE${NC}" >&2; exit 1; }

    check_dependencies
    show_menu

    # Upewnij się, że wszystkie pliki wyjściowe istnieją i są puste na początku w katalogu wyjściowym
    touch "$OUTPUT_DIR/all_subdomains.txt" "$OUTPUT_DIR/live_subdomains.txt" "$OUTPUT_DIR/found_urls.txt" "$OUTPUT_DIR/urls_with_params.txt" "$OUTPUT_DIR/vhost_status_200.txt"

    # Przetwarzanie celów
    if [ -n "$DOMAINS_FILE" ]; then
        while IFS= read -r domain_entry || [ -n "$domain_entry" ]; do
            domain=$(clean_domain "$domain_entry")
            is_valid_domain "$domain" && scan_domain "$domain"
        done < "$DOMAINS_FILE"
    else
        scan_domain "$URL"
    fi

    # Ostateczna konsolidacja i sortowanie głównych plików wyjściowych (na wypadek, gdyby coś zostało dodane w scan_domain)
    sort -u "$OUTPUT_DIR/all_subdomains.txt" -o "$OUTPUT_DIR/all_subdomains.txt"
    sort -u "$OUTPUT_DIR/found_urls.txt" -o "$OUTPUT_DIR/found_urls.txt"
    sort -u "$OUTPUT_DIR/urls_with_params.txt" -o "$OUTPUT_DIR/urls_with_params.txt"
    sort -u "$OUTPUT_DIR/vhost_status_200.txt" -o "$OUTPUT_DIR/vhost_status_200.txt"
    sort -u "$OUTPUT_DIR/live_subdomains.txt" -o "$OUTPUT_DIR/live_subdomains.txt"


    echo -e "\n${BLUE}Unikalne subdomeny: ${GREEN}$(wc -l < "$OUTPUT_DIR/all_subdomains.txt" 2>/dev/null || echo 0)${NC}"
    if [ ${SELECTED[1]} -eq 1 ] && [ -f "$OUTPUT_DIR/vhost_status_200.txt" ]; then
        echo -e "${BLUE}Vhosty ze statusem 200: ${GREEN}$(wc -l < "$OUTPUT_DIR/vhost_status_200.txt" 2>/dev/null || echo 0)${NC}"
    fi
    echo -e "${GREEN}Żywe hosty: $(wc -l < "$OUTPUT_DIR/live_subdomains.txt" 2>/dev/null || echo 0)${NC}"
    echo -e "${BLUE}Wszystkie znalezione URL-e (Waybackurls, Katana, Hakrawler): ${GREEN}$(wc -l < "$OUTPUT_DIR/found_urls.txt" 2>/dev/null || echo 0)${NC}"
    echo -e "${BLUE}URL-e z parametrami (Paramspider): ${GREEN}$(wc -l < "$OUTPUT_DIR/urls_with_params.txt" 2>/dev/null || echo 0)${NC}"


    # Generowanie raportu Markdown
    {
        echo "# Raport Subdomen"
        echo "**Data**: $(date)"
        echo "**Cel(e)**: ${URL:-$DOMAINS_FILE}"
        echo "**Użyte narzędzia**:"
        for i in "${!TOOLS[@]}"; do
            if [ ${SELECTED[i]} -eq 1 ]; then
                echo "- ${TOOLS[i]}"
            fi
        done
        echo "## Wyniki"
        echo "### Wszystkie subdomeny"
        wc -l < "$OUTPUT_DIR/all_subdomains.txt" 2>/dev/null || echo 0
        echo "### Żywe hosty"
        wc -l < "$OUTPUT_DIR/live_subdomains.txt" 2>/dev/null || echo 0
        if [ ${SELECTED[1]} -eq 1 ] && [ -f "$OUTPUT_DIR/vhost_status_200.txt" ]; then
            echo "### Vhosty ze statusem 200"
            wc -l < "$OUTPUT_DIR/vhost_status_200.txt" 2>/dev/null || echo 0
        fi
        if [ ${SELECTED[4]} -eq 1 ] || [ ${SELECTED[5]} -eq 1 ] || [ ${SELECTED[6]} -eq 1 ]; then
            echo "### Wszystkie znalezione URL-e"
            wc -l < "$OUTPUT_DIR/found_urls.txt" 2>/dev/null || echo 0
        fi
        if [ ${SELECTED[7]} -eq 1 ]; then
            echo "### URL-e z parametrami"
            wc -l < "$OUTPUT_DIR/urls_with_params.txt" 2>/dev/null || echo 0
        fi
        
        # Dodanie sekcji błędów do raportu
        if [ -s "$ERROR_LOG" ]; then # Tylko jeśli plik nie jest pusty
            echo "## Logi błędów"
            echo "Poniżej znajdują się błędy napotkane podczas działania narzędzi. Proszę sprawdzić plik '$ERROR_LOG' dla pełnych szczegółów."
            echo "\`\`\`"
            cat "$ERROR_LOG"
            echo "\`\`\`"
        fi

    } > "$OUTPUT_DIR/report.md"

    echo -e "\n${GREEN}Raport zapisany: $OUTPUT_DIR/report.md${NC}"
    echo -e "${BLUE}Wyniki:${NC}"
    echo -e "• Wszystkie subdomeny: $OUTPUT_DIR/all_subdomains.txt"
    echo -e "• Żywe hosty: $OUTPUT_DIR/live_subdomains.txt"
    if [ ${SELECTED[1]} -eq 1 ] && [ -f "$OUTPUT_DIR/vhost_status_200.txt" ]; then
        echo -e "• Vhosty: $OUTPUT_DIR/vhost_status_200.txt"
    fi
    if [ ${SELECTED[4]} -eq 1 ] || [ ${SELECTED[5]} -eq 1 ] || [ ${SELECTED[6]} -eq 1 ]; then
        echo -e "• Wszystkie znalezione URL-e: $OUTPUT_DIR/found_urls.txt"
    fi
    if [ ${SELECTED[7]} -eq 1 ]; then
        echo -e "• URL-e z parametrami: $OUTPUT_DIR/urls_with_params.txt"
    fi
    echo -e "• Logi błędów: $ERROR_LOG"

    if [ $JSON_OUTPUT -eq 1 ]; then
        generate_json_report "${URL:-$(head -n 1 "$DOMAINS_FILE" 2>/dev/null || echo "N/A")}" # Użyj pierwszej domeny z pliku, jeśli podano plik
    fi
}

main "$@"
