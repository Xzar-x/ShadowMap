#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# Kolory dla wyjścia konsoli
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # Brak koloru reset do domyślnego

# Domyślna konfiguracja
URL=""
DOMAINS_FILE=""
WORDLIST="/usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt"

# Zmienne globalne dla domeny i jej części (dostępne w funkcjach)
# Ustawiane są w funkcji scan_domain dla każdego przetwarzanego celu.
domain=""
domain_part=""
port_part=""

# Opcje Nmap
NMAP_LIGHT_SCAN=1 # Lekkie skanowanie domyślnie włączone
NMAP_DEEP_SCAN=0
NMAP_PORT_RANGE="" # Zakres portów dla Nmap, np. "1-1000" lub "80,443"

# Definicja narzędzi i ich nazw wyświetlanych w menu
TOOLS=(
"FFUF Subdomain"
"Gobuster Vhost"
"Subfinder"
"Amass (long scan)"
"Waybackurls"
"Katana"
"Hakrawler"
"Paramspider"
"CRT.sh" # Nowe narzędzie
"Nmap Scan" # Dodano Nmap
# Nuclei Scan i Gau Scan będą teraz zawsze aktywne i nie będą w menu
)

# Domyślny wybór dla wszystkich kluczowych narzędzi do wyliczania subdomen
# Długość SELECTED musi odpowiadać nowej długości TOOLS
SELECTED=(1 1 1 1 1 1 1 1 1 1) # Wszystkie wybrane domyślnie dla nowej listy TOOLS

# Opcje Amass
AMASS_PASSIVE=1
AMASS_BRUTE=0
AMASS_ACTIVE=0

# Globalny tryb cichy (0=wyłączony, 1=włączony)
QUIET_MODE=0

# Plik logu błędów
ERROR_LOG="ShadowMap_error.log"

# Opcje wyjścia
JSON_OUTPUT=0
OUTPUT_DIR="" # Domyślny katalog wyjściowy to bieżący

# Katalog tymczasowy (ustawiany w main)
TMPDIR=""

# Globalna zmienna dla opcji Amass, dostępna w run_tool
amass_opts_str=""

# Nowe zmienne dla limitowania zapytań i trybu ukrycia
RATE_LIMIT_MODE="MEDIUM" # Domyślny tryb limitowania
CUSTOM_RATE_LIMIT_THREADS="" # Niestandardowa liczba wątków dla trybu CUSTOM

THREADS="" # Domyślna liczba wątków, ustawiana przez set_rate_limit_options
TIMEOUT="" # Domyślny timeout, ustawiany przez set_rate_limit_options
DELAY_SECONDS=0 # Domyślne opóźnienie między żądaniami (w sekundach)
RANDOM_USER_AGENT_ENABLED=0 # Czy włączyć losowy User-Agent
USER_AGENTS=(
"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"
"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"
"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/109.0.1518.78"
"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.2 Safari/605.1.15"
"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/109.0"
"Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.86 Mobile Safari/537.36"
"Mozilla/5.0 (iPhone; CPU iPhone OS 16_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.3 Mobile/15E148 Safari/604.1"
"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36"
"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/109.0"
)
CURRENT_USER_AGENT="" # Aktualnie wybrany User-Agent
STEALTH_MODE=0 # Flaga trybu ukrycia

# Zmienne globalne dla opcji specyficznych dla narzędzi (ustawiane przez set_rate_limit_options)
FFUF_DELAY_OPT=""
FFUF_UA_OPT=""
GOBUSTER_DELAY_OPT=""
GOBUSTER_UA_OPT=""
SUBFINDER_DELAY_OPT=""
SUBFINDER_UA_OPT=""
AMASS_DELAY_OPT="" # Amass ma złożone opcje opóźnienia, często przez konfigurację
KATANA_DELAY_OPT=""
KATANA_UA_OPT=""
CURL_UA_OPT=""
HTTPX_DELAY_OPT=""
HTTPX_UA_OPT=""
NUCLEI_DELAY_OPT=""
NUCLEI_UA_OPT=""
GAU_DELAY_OPT=""
GAU_UA_OPT=""

# Tablica asocjacyjna dla komand narzędzi
# Używamy \$ do oznaczania zmiennych, które zostaną rozwinięte przez expand_vars
# Komendy teraz zawierają miejsca na dynamiczne opcje limitowania zapytań i User-Agenta
declare -A TOOL_CMDS=(
["FFUF Subdomain"]="ffuf -u 'https://FUZZ.\$domain_part' -w '\$WORDLIST' -recursion -recursion-depth 2 -t \$THREADS \$FFUF_DELAY_OPT \$FFUF_UA_OPT"
["Gobuster Vhost"]="gobuster vhost -u 'http://\$domain' --append-domain -w '\$WORDLIST' -t \$THREADS \$GOBUSTER_DELAY_OPT \$GOBUSTER_UA_OPT"
["Subfinder"]="subfinder -d '\$domain_part' -silent -t \$THREADS \$SUBFINDER_DELAY_OPT \$SUBFINDER_UA_OPT"
["Amass (long scan)"]="amass enum \$amass_opts_str -d '\$domain_part' -json /dev/stdout --config '\$HOME/.config/amass/config.yaml' \$AMASS_DELAY_OPT"
["Waybackurls"]="waybackurls '\$domain_part'" # Brak bezpośrednich flag dla opóźnienia/User-Agenta
["Katana"]="katana -silent -c \$THREADS \$KATANA_DELAY_OPT \$KATANA_UA_OPT"
["Hakrawler"]="hakrawler" # Brak bezpośrednich flag dla opóźnienia/User-Agenta
["Paramspider"]="paramspider -d '\$domain_part'" # Brak bezpośrednich flag dla opóźnienia/User-Agenta
["CRT.sh"]="curl -s \$CURL_UA_OPT 'https://crt.sh/?q=%25.\$domain_part&output=json' | jq -r '.[].common_name' | sed 's/^\*\.//g' | sort -u"
["Nmap Scan"]="nmap" # Placeholder, komenda będzie budowana dynamicznie w port_scan_stage
["Nuclei Scan"]="nuclei -l \$input_file -t ~/nuclei-templates/ -silent -o \$output_file \$NUCLEI_DELAY_OPT \$NUCLEI_UA_OPT"
["Gau Scan"]="gau -subs \$domain_part -t \$THREADS -o \$output_file \$GAU_DELAY_OPT \$GAU_UA_OPT"
)

# Szablon komendy dla httpx (również z miejscami na dynamiczne opcje)
HTTPX_CMD_TEMPLATE="httpx -l \"\$TMPDIR/all_subdomains.tmp\" -silent -threads \$THREADS -timeout \$TIMEOUT \$HTTPX_DELAY_OPT \$HTTPX_UA_OPT -o \"\$TMPDIR/live_subdomains.tmp\""
HTTPX_PORTS_CMD_TEMPLATE="httpx -l \"\$TMPDIR/live_subdomains.tmp\" -silent -threads \$THREADS -timeout \$TIMEOUT \$HTTPX_DELAY_OPT \$HTTPX_UA_OPT -ports 80,443,8000,8080,8443 -o \"\$TMPDIR/httpx_open_ports.tmp\""

# Funkcja do usuwania kodów ANSI escape dla obliczania długości
strip_ansi_codes() {
    echo "$1" | sed 's/\x1b\[[0-9;]*m//g'
}

# ASCII Art
print_title() {
    clear
    cat <<\EOF
   _____ __              __              __  ___          
  / ___// /_  ____ _____/ /___ _      __/  |/  /___ _____ 
  \__ \/ __ \/ __ `/ __  / __ \ | /| / / /|_/ / __ `/ __ \
 ___/ / / / / /_/ / /_/ / /_/ / |/ |/ / /  / / /_/ / /_/ /
/____/_/ /_/\__,_/\__,_/\____/|__/|__/_/  /_/\__,_/ .___/ 
                                                 /_/      
EOF
    echo -e "${NC}"
    echo -e "${BLUE} ShadowMap${NC} Automated Reconnaissance Toolkit"
    echo -e "${GREEN} Made by Xzar${NC}\n"
}

# Funkcja do zwracania ciągu przekierowania w zależności od QUIET_MODE
# Błędy są zawsze przekierowywane do ERROR_LOG
get_redirection_string() {
    if [ "$QUIET_MODE" -eq 1 ]; then
        echo ">/dev/null 2>> \"\$ERROR_LOG\"" # Przekieruj stdout do null, stderr do logu błędów
    else
        echo "2>> \"\$ERROR_LOG\"" # Przekieruj stderr do logu błędów
    fi
}

# Funkcja pomocnicza do rozwijania zmiennych w szablonie ciągu
# Ta funkcja używa eval, ale jest używana w kontrolowanym kontekście,
# gdzie szablon wejściowy pochodzi z hardkodowanych TOOL_CMDS, a
# zmienne są globalne i kontrolowane.
expand_vars() {
    local cmd_template="$1"
    # Użyj printf -v dla bezpiecznego tworzenia ciągu, a następnie eval
    printf -v safe_cmd "%s" "$cmd_template"
    eval "echo \"$safe_cmd\""
}

# Bezpieczne uruchamianie komendy, przekierowywanie stderr do ERROR_LOG
# Przyjmuje nazwę narzędzia/komendę i jej argumenty jako tablicę
# Zwraca kod wyjścia komendy
run_command_safely() {
    local tool_name_for_log="$1" # Pierwszy argument to nazwa narzędzia/komenda
    shift # Usuń nazwę narzędzia z argumentów, pozostałe to komenda i jej argumenty
    local cmd=("$@")

    # Uruchom komendę, przekieruj stderr do ERROR_LOG
    # stdout jest obsługiwane przez wywołującego (np. > "$output_file")
    "${cmd[@]}" 2>> "$ERROR_LOG"
    local exit_status=$?

    if [ "$exit_status" -ne 0 ]; then
        echo "$(date): BŁĄD: Narzędzie '$tool_name_for_log' zakończyło się z kodem wyjścia $exit_status. Sprawdź '$ERROR_LOG' dla szczegółów." >> "$ERROR_LOG"
    fi
    return "$exit_status"
}

# Funkcja do uruchamiania narzędzia i monitorowania go za pomocą spinnera
# Zwraca PID podpowłoki uruchamiającej narzędzie
run_tool() {
    local tool_name="$1"
    local cmd_template="$2" # To jest teraz pełny szablon komendy z TOOL_CMDS
    local output_file="$3" # Opcjonalnie: plik do przekierowania stdout
    local input_file="$4" # Opcjonalnie: plik wejściowy dla narzędzi (np. Katana, Hakrawler)

    # Rozwiń zmienne w szablonie komendy
    local expanded_cmd_str=$(expand_vars "$cmd_template")

    # Przetwórz rozwinięty ciąg komendy na tablicę dla bezpiecznego wykonania
    local cmd_array=()
    read -ra cmd_array <<< "$expanded_cmd_str"

    # Specjalna obsługa dla narzędzi, które nie mają bezpośrednich flag opóźnienia/User-Agenta
    if (( $(echo "$DELAY_SECONDS > 0" | bc -l) )) && \
       ([[ "$tool_name" == "Waybackurls" || "$tool_name" == "Hakrawler" || "$tool_name" == "Paramspider" ]]); then
        echo "$(date): UWAGA: Narzędzie '$tool_name' nie obsługuje bezpośrednio opóźnień per-żądanie. Globalne opóźnienie (${DELAY_SECONDS}s) nie zostanie zastosowane dla tego narzędzia." >> "$ERROR_LOG"
    fi

    if [ -n "$CURRENT_USER_AGENT" ] && \
       ([[ "$tool_name" == "Waybackurls" || "$tool_name" == "Hakrawler" || "$tool_name" == "Paramspider" || "$tool_name" == "Amass (long scan)" ]]); then
        echo "$(date): UWAGA: Narzędzie '$tool_name' nie obsługuje bezpośrednio ustawiania User-Agenta. Globalny User-Agent nie zostanie zastosowany dla tego narzędzia." >> "$ERROR_LOG"
    fi

    ( # Uruchom narzędzie w podpowłoce
        if [ -n "$input_file" ]; then
            if [ -n "$output_file" ]; then
                run_command_safely "$tool_name" "${cmd_array[@]}" < "$input_file" > "$output_file"
            else
                run_command_safely "$tool_name" "${cmd_array[@]}" < "$input_file"
            fi
        else
            if [ -n "$output_file" ]; then
                run_command_safely "$tool_name" "${cmd_array[@]}" > "$output_file"
            else
                run_command_safely "$tool_name" "${cmd_array[@]}"
            fi
        fi
    ) &
    echo $! # Zwróć PID podpowłoki uruchamiającej narzędzie
}

# Funkcja do wyświetlania animacji spinnera w tle
# Przyjmuje PIDy procesów do monitorowania i wiadomość
start_spinner() {
    if [ "$QUIET_MODE" -eq 1 ]; then
        return # Nie pokazuj spinnera w trybie cichym
    fi

    local msg="$1" # Pierwszy argument to wiadomość
    shift # Usuń wiadomość z argumentów, pozostałe to PIDy
    local pids_to_monitor=("$@") # Pobierz wszystkie pozostałe argumenty jako tablicę

    ( # Uruchom spinner w podpowłoce
        local spin='-\|/'
        local i=0
        local all_done=0
        local start_time=$(date +%s)
        local timeout_seconds=600 # Timeout spinnera po 10 minutach (600 sekund)

        while [ "$all_done" -eq 0 ]; do
            all_done=1
            for pid in "${pids_to_monitor[@]}"; do
                # Sprawdź, czy PID nadal działa
                if kill -0 "$pid" 2>/dev/null; then
                    all_done=0
                    break
                fi
            done

            local current_time=$(date +%s)
            if ((current_time - start_time > timeout_seconds)); then
                echo -ne "\r${RED}× ${msg} przekroczono limit czasu (${timeout_seconds}s)!${NC}\n"
                # Zabij procesy, które przekroczyły limit czasu
                for pid in "${pids_to_monitor[@]}"; do
                    kill "$pid" 2>/dev/null
                done
                exit 1 # Wyjdź z podpowłoki spinnera
            fi

            i=$(((i+1) % 4))
            echo -ne "\r${YELLOW}${spin:$i:1} ${msg} ...${NC}"
            sleep 0.1
        done
        echo -ne "\r${GREEN}✓ ${msg} zakończono!${NC}\n"
    ) &
    echo $! # Zwróć PID podpowłoki spinnera
}

# Funkcja do ustawiania opcji limitowania zapytań i User-Agenta
set_rate_limit_options() {
    # Resetuj domyślne wartości dla THREADS i TIMEOUT na podstawie trybu
    case "$RATE_LIMIT_MODE" in
        "LOW")
            THREADS=5
            TIMEOUT=60
            DELAY_SECONDS=2
            RANDOM_USER_AGENT_ENABLED=1
            ;;
        "MEDIUM")
            THREADS=20
            TIMEOUT=45
            DELAY_SECONDS=0.5
            RANDOM_USER_AGENT_ENABLED=0
            ;;
        "HIGH")
            THREADS=40 # Można zwiększyć dla agresywnych skanów
            TIMEOUT=30
            DELAY_SECONDS=0
            RANDOM_USER_AGENT_ENABLED=0
            ;;
        "CUSTOM")
            if [ -n "$CUSTOM_RATE_LIMIT_THREADS" ]; then
                THREADS="$CUSTOM_RATE_LIMIT_THREADS"
            fi
            # TIMEOUT i DELAY_SECONDS pozostają jako ich początkowe
            # wartości domyślne lub jako ustawione przez poprzednie opcje, jeśli nie są jawnie zmieniane
            ;;
        *)
            # Domyślnie na MEDIUM, jeśli tryb jest nieprawidłowy
            THREADS=20
            TIMEOUT=45
            DELAY_SECONDS=0.5
            RANDOM_USER_AGENT_ENABLED=0
            ;;
    esac

    # Jeśli tryb ukrycia jest włączony, nadpisz ustawienia na LOW
    if [ "$STEALTH_MODE" -eq 1 ]; then
        RATE_LIMIT_MODE="LOW" # Wymus LOW dla trybu ukrycia
        THREADS=5
        TIMEOUT=60
        DELAY_SECONDS=2
        RANDOM_USER_AGENT_ENABLED=1
        echo -e "${YELLOW}Tryb --stealth aktywowany: Ustawiono tryb LOW, opóźnienia i losowy User-Agent.${NC}"
    fi

    # Ustaw losowy User-Agent, jeśli włączony
    if [ "$RANDOM_USER_AGENT_ENABLED" -eq 1 ]; then
        CURRENT_USER_AGENT="${USER_AGENTS[$((RANDOM % ${#USER_AGENTS[@]}))]}"
    else
        CURRENT_USER_AGENT="" # Resetuj, jeśli nie losowy
    fi

    # Ustaw ciągi opcji specyficznych dla narzędzi na podstawie ustawień globalnych
    FFUF_DELAY_OPT=""
    GOBUSTER_DELAY_OPT=""
    SUBFINDER_DELAY_OPT=""
    AMASS_DELAY_OPT="" # Amass: opóźnienie jest złożone, często przez konfigurację
    KATANA_DELAY_OPT=""
    HTTPX_DELAY_OPT=""
    NUCLEI_DELAY_OPT=""
    GAU_DELAY_OPT=""

    if (( $(echo "$DELAY_SECONDS > 0" | bc -l) )); then
        FFUF_DELAY_OPT="-delay ${DELAY_SECONDS}s"
        GOBUSTER_DELAY_OPT="-delay ${DELAY_SECONDS}s" # Gobuster oczekuje sufiksu 's'
        SUBFINDER_DELAY_OPT="-delay ${DELAY_SECONDS}s"
        KATANA_DELAY_OPT="-delay ${DELAY_SECONDS}s"
        HTTPX_DELAY_OPT="-delay ${DELAY_SECONDS}s"
        NUCLEI_DELAY_OPT="-delay ${DELAY_SECONDS}s"
        GAU_DELAY_OPT="-delay ${DELAY_SECONDS}s"
    fi

    FFUF_UA_OPT=""
    GOBUSTER_UA_OPT=""
    SUBFINDER_UA_OPT=""
    KATANA_UA_OPT=""
    CURL_UA_OPT=""
    HTTPX_UA_OPT=""
    NUCLEI_UA_OPT=""
    GAU_UA_OPT=""

    if [ -n "$CURRENT_USER_AGENT" ]; then
        FFUF_UA_OPT="-H \"User-Agent: $CURRENT_USER_AGENT\""
        GOBUSTER_UA_OPT="-U \"$CURRENT_USER_AGENT\""
        SUBFINDER_UA_OPT="-ua \"$CURRENT_USER_AGENT\""
        KATANA_UA_OPT="-H \"User-Agent: $CURRENT_USER_AGENT\""
        CURL_UA_OPT="-A \"$CURRENT_USER_AGENT\""
        HTTPX_UA_OPT="-H \"User-Agent: $CURRENT_USER_AGENT\""
        NUCLEI_UA_OPT="-H \"User-Agent: $CURRENT_USER_AGENT\""
        GAU_UA_OPT="-H \"User-Agent: $CURRENT_USER_AGENT\""
    fi
}

# Funkcja do pobierania domyślnej listy słów, jeśli nie istnieje
download_default_wordlist() {
    echo -e "${YELLOW}Lista słów nie znaleziona: $WORDLIST. Próbuję pobrać domyślną listę słów...${NC}"
    local dir=$(dirname "$WORDLIST")
    sudo mkdir -p "$dir"
    sudo wget -O "$WORDLIST" "https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/DNS/subdomains-top1million-5000.txt" 2>> "$ERROR_LOG"
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Domyślna lista słów pobrana pomyślnie.${NC}"
    else
        echo -e "${RED}Błąd: Nie udało się pobrać domyślnej listy słów. Upewnij się, że masz połączenie z internetem i odpowiednie uprawnienia.${NC}" >> "$ERROR_LOG"
        exit 1
    fi
}

# Sprawdzanie zależności
check_dependencies () {
    local missing=0
    # Dodano 'httpx', 'jq', 'curl', 'nmap', 'bc', 'nuclei', 'gau' do listy narzędzi do sprawdzenia
    local tools=(ffuf gobuster subfinder amass jq httpx waybackurls katana hakrawler paramspider curl nmap nuclei gau bc)

    echo -e "${BLUE}Sprawdzanie zależności...${NC}"
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" &>/dev/null; then
            echo -e "${RED} Brak: $tool${NC}" >&2
            missing=1
        else
            echo -e "${GREEN} Znaleziono: $tool${NC}"
        fi
    done

    # Lepsze sprawdzenie dla paramspider
    if ! command -v "paramspider" &> /dev/null; then
        echo -e "${RED} Brak: paramspider (upewnij się, że jest zainstalowany i w PATH, np. /usr/local/bin/paramspider. Spróbuj 'pip install paramspider' lub 'git clone https://github.com/0xasm0d3us/ParamSpider.git' i dodaj do PATH.)${NC}" >&2
        missing=1
    else
        echo -e "${GREEN} Znaleziono: paramspider${NC}"
    fi

    if [ "$missing" -eq 1 ]; then
        echo -e "\n${RED} Brak wymaganych narzędzi. Zainstaluj je przed kontynuowaniem.${NC}" >&2
        echo "Sprawdź $ERROR_LOG dla szczegółów." # Informacje o pliku logu
        exit 1
    fi
}

# Główne menu
show_menu() {
    clear # Wyczyść ekran raz na początku menu
    while true; do
        print_title
        echo -e "${YELLOW}Wybierz narzędzia: [0-${#TOOLS[@]}) przełącz główne narzędzia, [a/s/d] przełącz opcje Amass, [e/f] przełącz opcje Nmap, [p] ustaw zakres portów Nmap, [q] przełącz tryb cichy, ENTER aby kontynuować${NC}"

        local num_tools=${#TOOLS[@]}
        local half_num=$(((num_tools + 1) / 2)) # Zaokrąglij w górę dla pierwszej kolumny

        # Oblicz maksymalną widoczną długość dla elementów lewej kolumny
        local max_left_col_visible_len=0
        local left_col_display_strings=() # Tablica do przechowywania widocznych ciągów dla lewej kolumny
        for ((i=0; i<half_num; i++)); do
            local status_char_for_calc=$( [ ${SELECTED[i]} -eq 1 ] && echo "✓" || echo "✗" )
            # Zbuduj ciąg dokładnie tak, jak będzie wyświetlany (bez kodów kolorów)
            local visible_string=" [$i] ${status_char_for_calc} ${TOOLS[i]}"
            left_col_display_strings+=("$visible_string")
            local current_len=$(strip_ansi_codes "$visible_string" | wc -c)
            if (( current_len > max_left_col_visible_len )); then
                max_left_col_visible_len=$current_len
            fi
        done

        # Dodaj trochę dodatkowego wypełnienia dla separacji między kolumnami
        local column_padding_width=$((max_left_col_visible_len + 2))

        for ((i=0; i<half_num; i++)); do
            local left_status_char=$( [ ${SELECTED[i]} -eq 1 ] && echo "✓" || echo "✗" )
            local left_color=$( [ ${SELECTED[i]} -eq 1 ] && echo "${GREEN}" || echo "${RED}" )
            # Pełny tekst z kodami ANSI do wyświetlenia
            local left_full_text=" ${left_color}[$i] ${left_status_char} ${TOOLS[i]}${NC}"

            # Pobierz widoczny ciąg dla bieżącego elementu (z wstępnie obliczonej tablicy)
            local current_left_item_visible_string="${left_col_display_strings[i]}"
            local current_left_item_visible_len=$(strip_ansi_codes "$current_left_item_visible_string" | wc -c)

            local right_full_text=""
            local right_index=$((i + half_num))
            if [ "$right_index" -lt "$num_tools" ]; then
                local right_status_char=$( [ ${SELECTED[$right_index]} -eq 1 ] && echo "✓" || echo "✗" )
                local right_color=$( [ ${SELECTED[$right_index]} -eq 1 ] && echo "${GREEN}" || echo "${RED}" )
                right_full_text=" ${right_color}[$right_index] ${right_status_char} ${TOOLS[$right_index]}${NC}"
            fi

            # Oblicz wypełnienie na podstawie maksymalnej znalezionej długości
            local padding=$(( column_padding_width - current_left_item_visible_len ))
            if [ "$padding" -lt 0 ]; then padding=0; fi # Upewnij się, że wypełnienie nie jest ujemne

            # Wyświetl wiersz, stosując kolory i wypełnienie
            echo -e "${left_full_text}$(printf '%*s' "$padding" "")${right_full_text}"
        done

        # Opcje Amass (bardziej kompaktowe, w jednej linii)
        if [ ${SELECTED[3]} -eq 1 ]; then
            local passive_status=$( [ $AMASS_PASSIVE -eq 1 ] && echo -e "${GREEN}on" || echo -e "${RED}off" )
            local brute_status=$( [ $AMASS_BRUTE -eq 1 ] && echo -e "${GREEN}on" || echo -e "${RED}off" )
            local active_status=$( [ $AMASS_ACTIVE -eq 1 ] && echo -e "${GREEN}on" || echo -e "${RED}off" )
            echo -e " ${BLUE}Amass: ${YELLOW}[a]${BLUE}Pasywne:${passive_status} ${YELLOW}[s]${BLUE}Brute:${brute_status} ${YELLOW}[d]${BLUE}Aktywne:${active_status}${NC}"
        else
            echo -e " (Opcje Amass wyłączone)"
        fi

        # Znajdź indeks Nmap Scan dynamicznie
        local nmap_index=-1
        for idx in "${!TOOLS[@]}"; do
            if [[ "${TOOLS[$idx]}" == "Nmap Scan" ]]; then
                nmap_index=$idx
                break
            fi
        done

        # Dodaj opcje Nmap do menu, jeśli Nmap jest wybrany
        if [ "$nmap_index" -ne -1 ] && [ ${SELECTED[$nmap_index]} -eq 1 ]; then
            local light_status=$( [ $NMAP_LIGHT_SCAN -eq 1 ] && echo -e "${GREEN}on" || echo -e "${RED}off" )
            local deep_status=$( [ $NMAP_DEEP_SCAN -eq 1 ] && echo -e "${GREEN}on" || echo -e "${RED}off" )
            echo -e " ${BLUE}Nmap: ${YELLOW}[e]${BLUE}Lekkie:${light_status} ${YELLOW}[f]${BLUE}Głębokie:${deep_status} ${YELLOW}[p]${BLUE}Porty:${GREEN}${NMAP_PORT_RANGE:-Domyślne (top 1000)}${NC}"
        else
            echo -e " (Opcje Nmap wyłączone)"
        fi

        echo -e "${BLUE}Aktualne ustawienia:${NC}"
        # Wyświetl ustawienia na mniejszej liczbie linii
        local domain_display="${URL:-$DOMAINS_FILE}"
        echo -e " Domena: ${GREEN}${domain_display}${NC}"
        echo -e " Lista słów: ${GREEN}${WORDLIST}${NC}"
        echo -e " Wątki: ${GREEN}${THREADS}${NC}, Timeout: ${GREEN}${TIMEOUT}s${NC}"
        echo -e " Limit zapytań: ${GREEN}${RATE_LIMIT_MODE}${NC}"
        if [ "$RATE_LIMIT_MODE" == "CUSTOM" ]; then
            echo -e " (Wątki niestandardowe: ${GREEN}${CUSTOM_RATE_LIMIT_THREADS}${NC})"
        fi
        if (( $(echo "$DELAY_SECONDS > 0" | bc -l) )); then
            echo -e " Opóźnienie: ${GREEN}${DELAY_SECONDS}s${NC}"
        fi
        if [ -n "$CURRENT_USER_AGENT" ]; then
            echo -e " User-Agent: ${GREEN}${CURRENT_USER_AGENT}${NC} (Losowy: ${RANDOM_USER_AGENT_ENABLED})${NC}"
        else
            echo -e " User-Agent: ${RED}Domyślny (brak losowego)${NC}"
        fi
        if [ "$QUIET_MODE" -eq 1 ]; then
            echo -e " ${GREEN}[q] Tryb cichy: włączony${NC}"
        else
            echo -e " ${NC}${RED}[q] Tryb cichy: wyłączony${NC}"
        fi
        if [ "$STEALTH_MODE" -eq 1 ]; then
            echo -e " ${GREEN}[--stealth] Tryb ukrycia: włączony${NC}"
        else
            echo -e " ${NC}${RED}[--stealth] Tryb ukrycia: wyłączony${NC}"
        fi
        if [ -n "$OUTPUT_DIR" ]; then
            echo -e " ${BLUE}Katalog wyjściowy: ${GREEN}${OUTPUT_DIR}${NC}"
        fi
        if [ "$JSON_OUTPUT" -eq 1 ]; then
            echo -e " ${BLUE}Wyjście JSON: włączone${NC}"
        fi
        echo -e " ${BLUE}Nuclei Scan: ${GREEN}Zawsze aktywny${NC}"
        echo -e " ${BLUE}Gau Scan: ${GREEN}Zawsze aktywny${NC}"


        echo -e "Naciśnij 0-${#TOOLS[@]} aby przełączyć narzędzia, a/s/d dla opcji Amass, e/f dla opcji Nmap, p dla zakresu portów Nmap, q dla trybu cichego, ENTER aby rozpocząć"
        read -sn1 key
        [[ -z "$key" ]] && break

        if [[ "$key" =~ ^[0-9]+$ ]] && [ "$key" -ge 0 ] && [ "$key" -lt "${#TOOLS[@]}" ]; then
            index=$key
            SELECTED[$index]=$((1 - SELECTED[$index]))
        elif [[ "$key" == "a" && ${SELECTED[3]} -eq 1 ]]; then
            AMASS_PASSIVE=$((1 - AMASS_PASSIVE))
        elif [[ "$key" == "s" && ${SELECTED[3]} -eq 1 ]]; then
            AMASS_BRUTE=$((1 - AMASS_BRUTE))
        elif [[ "$key" == "q" ]]; then
            QUIET_MODE=$((1 - QUIET_MODE))
        elif [[ "$key" == "d" && ${SELECTED[3]} -eq 1 ]]; then
            AMASS_ACTIVE=$((1 - AMASS_ACTIVE))
        elif [[ "$key" == "e" ]] && [ "$nmap_index" -ne -1 ] && [ ${SELECTED[$nmap_index]} -eq 1 ]; then
            NMAP_LIGHT_SCAN=$((1 - NMAP_LIGHT_SCAN))
            [ "$NMAP_LIGHT_SCAN" -eq 1 ] && NMAP_DEEP_SCAN=0 # Upewnij się, że są wzajemnie wykluczające się
        elif [[ "$key" == "f" ]] && [ "$nmap_index" -ne -1 ] && [ ${SELECTED[$nmap_index]} -eq 1 ]; then
            NMAP_DEEP_SCAN=$((1 - NMAP_DEEP_SCAN))
            [ "$NMAP_DEEP_SCAN" -eq 1 ] && NMAP_LIGHT_SCAN=0 # Upewnij się, że są wzajemnie wykluczające się
        elif [[ "$key" == "p" ]] && [ "$nmap_index" -ne -1 ] && [ ${SELECTED[$nmap_index]} -eq 1 ]; then
            echo -e "\n${YELLOW}Podaj zakres portów dla Nmap (np. 1-1000, 80,443, lub pozostaw puste dla domyślnych top 1000):${NC}"
            read -r NMAP_PORT_RANGE_INPUT
            NMAP_PORT_RANGE="$NMAP_PORT_RANGE_INPUT"
        fi
        clear # Wyczyść ekran przed ponownym rysowaniem menu w następnej iteracji
    done
}

# Walidacja domeny
validate_domain() {
    # Ulepszona walidacja domeny, która obsługuje również porty
    local domain_to_check="$1"
    # Usuń protokół i ścieżkę, aby sprawdzić tylko część domeny
    domain_to_check=$(echo "$domain_to_check" | sed -e 's|^[^/]*//||' -e 's|/.*$||')
    # Regex dla domeny (bez portu)
    local domain_regex='^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$'
    # Sprawdź, czy zawiera port
    local domain_part_no_port=$(echo "$domain_to_check" | cut -d':' -f1)
    local port_part_only=$(echo "$domain_to_check" | grep -q ':' && echo "$domain_to_check" | cut -d':' -f2 || echo "")

    if [[ ! "$domain_part_no_port" =~ $domain_regex ]]; then
        echo -e "${RED}Nieprawidłowy format domeny: $1${NC}" >&2
        return 1
    fi

    # Waliduj port, jeśli istnieje
    if [ -n "$port_part_only" ]; then
        if ! [[ "$port_part_only" =~ ^[0-9]+$ ]] || (( port_part_only < 1 )) || (( port_part_only > 65535 )); then
            echo -e "${RED}Nieprawidłowy format portu w domenie: $1${NC}" >&2
            return 1
        fi
    fi
    return 0
}

clean_domain() {
    echo "$1" | sed -e 's|^[^/]*//||' -e 's|/.*$||' -e 's/^www\.//'
}

# Etap 1: Wyliczanie Subdomen
recon_stage() {
    echo -e "${BLUE}Rozpoczynanie Etapu 1: Wyliczanie Subdomen dla ${GREEN}$domain${NC}"
    local pids_stage1=() # PIDy dla narzędzi do wyliczania subdomen

    # Skonfiguruj opcje Amass (musi być wykonane przed każdym wywołaniem Amass)
    local amass_opts=()
    if [ "$AMASS_PASSIVE" -eq 0 ] && [ "$AMASS_BRUTE" -eq 0 ] && [ "$AMASS_ACTIVE" -eq 0 ]; then
        AMASS_PASSIVE=1
    fi
    [ "$AMASS_PASSIVE" -eq 1 ] && amass_opts+=("-passive")
    [ "$AMASS_BRUTE" -eq 1 ] && amass_opts+=("-brute")
    [ "$AMASS_ACTIVE" -eq 1 ] && amass_opts+=("-active")
    amass_opts_str="${amass_opts[@]}" # Ustaw zmienną globalną

    for i in "${!TOOLS[@]}"; do
        local tool_name="${TOOLS[$i]}"
        local cmd_template="${TOOL_CMDS[$tool_name]}"
        local output_file=""
        local input_file="" # Nie używane w tym etapie, ale dla spójności

        if [ ${SELECTED[$i]} -eq 1 ]; then
            case "$tool_name" in
                "FFUF Subdomain")
                    echo -e "${BLUE}[+] FFUF Subdomain${NC}"
                    output_file="$TMPDIR/ffuf_subdomains.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                "Gobuster Vhost")
                    echo -e "${BLUE}[+] Gobuster Vhost${NC}"
                    output_file="$TMPDIR/gobuster_vhost.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                "Subfinder")
                    echo -e "${BLUE}[+] Subfinder${NC}"
                    output_file="$TMPDIR/subfinder_subdomains.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                "Amass (long scan)")
                    echo -e "${BLUE}[+] Amass${NC}"
                    output_file="$TMPDIR/amass_subdomains.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                "CRT.sh")
                    echo -e "${BLUE}[+] CRT.sh${NC}"
                    output_file="$TMPDIR/crtsh_subdomains.tmp"
                    pids_stage1+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                *)
                    # Narzędzia nie będące częścią etapu rekonesansu, lub już obsłużone
                    ;;
            esac
        fi
    done

    # Poczekaj, aż wszystkie procesy Etapu 1 zakończą się
    if [ ${#pids_stage1[@]} -gt 0 ]; then
        spinner_pid=$(start_spinner "Etap 1: Wyliczanie Subdomen" "${pids_stage1[@]}")
        for pid in "${pids_stage1[@]}"; do
            if ! wait "$pid"; then
                echo "${RED}Error in tool with PID $pid during Subdomain Enumeration.${NC}" >> "$ERROR_LOG"
            fi
        done
        kill "$spinner_pid" 2>/dev/null
    fi

    # Skonsoliduj wszystkie subdomeny i znajdź live hosty po Etapie 1
    echo -e "\n${BLUE}Finalizowanie Etapu 1 i sprawdzanie live hostów...${NC}"
    # Skonsoliduj wszystkie tymczasowe pliki subdomen
    sort -u "$TMPDIR/ffuf_subdomains.tmp" "$TMPDIR/gobuster_vhost.tmp" \
             "$TMPDIR/subfinder_subdomains.tmp" "$TMPDIR/amass_subdomains.tmp" \
             "$TMPDIR/crtsh_subdomains.tmp" 2>/dev/null -o "$TMPDIR/all_subdomains.tmp"

    echo -e "${BLUE}Unikalne subdomeny po Etapie 1: ${GREEN}$(wc -l < "$TMPDIR/all_subdomains.tmp" 2>/dev/null || echo 0)${NC}"

    echo -e "${BLUE}Sprawdzanie live hostów za pomocą httpx...${NC}"
    # Upewnij się, że httpx działa i tworzy live_subdomains.tmp przed narzędziami Etapu 2
    if [ -s "$TMPDIR/all_subdomains.tmp" ]; then # Sprawdź, czy plik nie jest pusty
        (
            if run_tool "httpx" "$HTTPX_CMD_TEMPLATE"; then
                echo "$(date): INFO: httpx zakończył się pomyślnie dla $domain." >> "$ERROR_LOG"
            else
                echo -e "${RED}BŁĄD: httpx nie znalazł live hostów dla $domain! Sprawdź '$ERROR_LOG' dla szczegółów.${NC}" >&2
                echo "$(date): BŁĄD: httpx nie znalazł live hostów dla $domain." >> "$ERROR_LOG"
                # Upewnij się, że plik istnieje, nawet jeśli jest pusty, aby kolejne sprawdzenia nie zakończyły się błędem "No such file"
                touch "$TMPDIR/live_subdomains.tmp"
            fi
        ) &
        httpx_pid=$!
        spinner_pid=$(start_spinner "Sprawdzanie live hostów" "$httpx_pid")
        if ! wait "$httpx_pid"; then
            echo "${RED}Error in httpx during live host check.${NC}" >> "$ERROR_LOG"
            touch "$TMPDIR/live_subdomains.tmp" # Ensure file exists even on error
        fi
        kill "$spinner_pid" 2>/dev/null
    else
        echo -e "${YELLOW}Brak subdomen do sprawdzenia za pomocą httpx. Tworzenie pustego live_subdomains.tmp.${NC}"
        touch "$TMPDIR/live_subdomains.tmp"
    fi
    echo -e "${BLUE}Live hosty: ${GREEN}$(wc -l < "$TMPDIR/live_subdomains.tmp" 2>/dev/null || echo 0)${NC}"
}

# Nowy etap: Skanowanie portów za pomocą httpx przed Nmapem
pre_scan_httpx_ports() {
    echo -e "\n${BLUE}Rozpoczynanie wstępnego skanowania portów za pomocą httpx dla ${GREEN}$domain${NC}"
    local pids_httpx_ports=()

    if [ -s "$TMPDIR/live_subdomains.tmp" ]; then
        echo -e "${BLUE}[+] httpx (porty)${NC}"
        (
            if run_tool "httpx_ports" "$HTTPX_PORTS_CMD_TEMPLATE"; then
                echo "$(date): INFO: httpx (porty) zakończył się pomyślnie dla $domain." >> "$ERROR_LOG"
            else
                echo -e "${RED}BŁĄD: httpx (porty) nie znalazł otwartych portów dla $domain! Sprawdź '$ERROR_LOG' dla szczegółów.${NC}" >&2
                echo "$(date): BŁĄD: httpx (porty) nie znalazł otwartych portów dla $domain." >> "$ERROR_LOG"
                touch "$TMPDIR/httpx_open_ports.tmp"
            fi
        ) &
        httpx_ports_pid=$!
        pids_httpx_ports+=("$httpx_ports_pid")
    else
        echo -e "${YELLOW}Brak live hostów do wstępnego skanowania portów za pomocą httpx. Pomijam wstępne skanowanie portów.${NC}"
        touch "$TMPDIR/httpx_open_ports.tmp"
    fi

    if [ ${#pids_httpx_ports[@]} -gt 0 ]; then
        spinner_pid=$(start_spinner "Wstępne skanowanie portów httpx" "${pids_httpx_ports[@]}")
        for pid in "${pids_httpx_ports[@]}"; do
            if ! wait "$pid"; then
                echo "${RED}Error in httpx during pre-scan port check.${NC}" >> "$ERROR_LOG"
            fi
        done
        kill "$spinner_pid" 2>/dev/null
    fi
    echo -e "${BLUE}Otwarte porty znalezione przez httpx: ${GREEN}$(wc -l < "$TMPDIR/httpx_open_ports.tmp" 2>/dev/null || echo 0)${NC}"
}


# Etap 2: Crawling i Odkrywanie Parametrów
crawl_stage() {
    echo -e "\n${BLUE}Rozpoczynanie Etapu 2: Crawling i Odkrywanie Parametrów dla ${GREEN}$domain${NC}"
    local pids_stage2=() # PIDy dla narzędzi do crawlingu/odkrywania parametrów

    for i in "${!TOOLS[@]}"; do
        local tool_name="${TOOLS[$i]}"
        local cmd_template="${TOOL_CMDS[$tool_name]}"
        local output_file=""
        local input_file=""

        if [ ${SELECTED[$i]} -eq 1 ]; then
            case "$tool_name" in
                "Katana")
                    echo -e "${BLUE}[+] Katana${NC}"
                    output_file="$TMPDIR/katana_out.tmp"
                    input_file="$TMPDIR/live_subdomains.tmp"
                    if [ ! -s "$input_file" ]; then
                        echo -e "${YELLOW}Brak live hostów do skanowania za pomocą Katany lub live_subdomains.tmp jest pusty. Pomijam Katana.${NC}"
                        continue # Pomiń to narzędzie, jeśli brak danych wejściowych
                    fi
                    pids_stage2+=($(run_tool "$tool_name" "$cmd_template" "$output_file" "$input_file"))
                    ;;
                "Hakrawler")
                    echo -e "${BLUE}[+] Hakrawler${NC}"
                    output_file="$TMPDIR/hakrawler_out.tmp"
                    input_file="$TMPDIR/live_subdomains.tmp"
                    if [ ! -s "$input_file" ]; then
                        echo -e "${YELLOW}Brak live hostów do skanowania za pomocą Hakrawlera lub live_subdomains.tmp jest pusty. Pomijam Hakrawler.${NC}"
                        continue # Pomiń to narzędzie, jeśli brak danych wejściowych
                    fi
                    pids_stage2+=($(run_tool "$tool_name" "$cmd_template" "$output_file" "$input_file"))
                    ;;
                "Paramspider")
                    echo -e "${BLUE}[+] Paramspider${NC}"
                    output_file="$TMPDIR/paramspider_out.tmp"
                    pids_stage2+=($(run_tool "$tool_name" "$cmd_template" "$output_file"))
                    ;;
                *)
                    # Narzędzia nie będące częścią etapu crawlingu, lub już obsłużone
                    ;;
            esac
        fi
    done

    # Uruchom Nuclei Scan (zawsze aktywny)
    echo -e "${BLUE}[+] Nuclei Scan (zawsze aktywny)${NC}"
    local nuclei_output_file="$TMPDIR/nuclei_out.tmp"
    local nuclei_input_file="$TMPDIR/live_subdomains.tmp"
    if [ -s "$nuclei_input_file" ]; then
        pids_stage2+=($(run_tool "Nuclei Scan" "${TOOL_CMDS["Nuclei Scan"]}" "$nuclei_output_file" "$nuclei_input_file"))
    else
        echo -e "${YELLOW}Brak live hostów do skanowania za pomocą Nuclei. Pomijam Nuclei Scan.${NC}"
        touch "$nuclei_output_file" # Upewnij się, że plik istnieje, nawet jeśli jest pusty
    fi

    # Uruchom Gau Scan (zawsze aktywny)
    echo -e "${BLUE}[+] Gau Scan (zawsze aktywny)${NC}"
    local gau_output_file="$TMPDIR/gau_out.tmp"
    # Gau używa domeny bezpośrednio, nie pliku wejściowego
    pids_stage2+=($(run_tool "Gau Scan" "${TOOL_CMDS["Gau Scan"]}" "$gau_output_file"))


    # Poczekaj, aż wszystkie procesy Etapu 2 zakończą się
    if [ ${#pids_stage2[@]} -gt 0 ]; then
        spinner_pid=$(start_spinner "Etap 2: Crawling i Parametry" "${pids_stage2[@]}")
        for pid in "${pids_stage2[@]}"; do
            if ! wait "$pid"; then
                echo "${RED}Error in tool with PID $pid during Crawling and Parameter Discovery.${NC}" >> "$ERROR_LOG"
            fi
        done
        kill "$spinner_pid" 2>/dev/null
    fi
    echo -ne "\r${GREEN}✓ Crawling zakończono!${NC}\n"
}

# Etap 3: Skanowanie Portów (Nmap)
port_scan_stage() {
    echo -e "\n${BLUE}Rozpoczynanie Etapu 3: Skanowanie Portów (Nmap) dla ${GREEN}$domain${NC}"
    local pids_stage3=() # PIDy dla Nmap

    # Znajdź indeks Nmap Scan dynamicznie
    local nmap_index=-1
    for idx in "${!TOOLS[@]}"; do
        if [[ "${TOOLS[$idx]}" == "Nmap Scan" ]]; then
            nmap_index=$idx
            break
        fi
    done

    if [ "$nmap_index" -ne -1 ] && [ ${SELECTED[$nmap_index]} -eq 1 ]; then # Sprawdź, czy Nmap jest wybrany
        echo -e "${BLUE}[+] Nmap Scan${NC}"
        if [ -s "$TMPDIR/live_subdomains.tmp" ]; then
            local nmap_cmd_options=""
            local nmap_timing_template="-T4" # Domyślne T4 (agresywne)

            if [ $NMAP_DEEP_SCAN -eq 1 ]; then
                nmap_cmd_options="-p- --script vuln"
                nmap_timing_template="-T2" # Wolniejsze dla głębokiego skanowania
            elif [ $NMAP_LIGHT_SCAN -eq 1 ]; then
                nmap_cmd_options="-Pn -sC -sV"
                nmap_timing_template="-T4"
            else # Domyślnie, jeśli ani lekkie, ani głębokie nie są jawnie wybrane
                nmap_cmd_options="-Pn -sC -sV"
                nmap_timing_template="-T4"
            fi

            # Dodaj niestandardowy zakres portów, jeśli podany
            if [ -n "$NMAP_PORT_RANGE" ]; then
                nmap_cmd_options+=" -p $NMAP_PORT_RANGE"
            elif [ -s "$TMPDIR/httpx_open_ports.tmp" ]; then
                # Użyj portów znalezionych przez httpx, jeśli plik istnieje i nie jest pusty
                local httpx_ports=$(cat "$TMPDIR/httpx_open_ports.tmp" | grep -oP ':\K\d+' | sort -u | paste -sd, -)
                if [ -n "$httpx_ports" ]; then
                    echo -e "${BLUE}Nmap użyje portów znalezionych przez httpx: ${httpx_ports}${NC}"
                    nmap_cmd_options+=" -p $httpx_ports"
                else
                    echo -e "${YELLOW}Brak otwartych portów z httpx, Nmap użyje domyślnych top 1000 portów.${NC}"
                fi
            fi

            # Dodaj opóźnienie skanowania Nmap, jeśli jest ustawione
            local nmap_delay_opt=""
            if (( $(echo "$DELAY_SECONDS > 0" | bc -l) )); then
                nmap_delay_opt="--scan-delay ${DELAY_SECONDS}s"
            fi

            # Użyj -iL dla pliku wejściowego, -oA dla wszystkich formatów wyjścia
            local nmap_full_cmd="nmap -iL \"\$TMPDIR/live_subdomains.tmp\" \$nmap_timing_template \$nmap_cmd_options -oA \"\$OUTPUT_DIR/${domain_part}_nmap\" $nmap_delay_opt"
            pids_stage3+=($(run_tool "Nmap Scan" "$nmap_full_cmd"))
        else
            echo -e "${YELLOW}Brak live hostów do skanowania za pomocą Nmapa lub live_subdomains.tmp jest pusty. Pomijam Nmap Scan.${NC}"
        fi
    fi

    # Poczekaj, aż procesy Nmap zakończą się
    if [ ${#pids_stage3[@]} -gt 0 ]; then
        spinner_pid=$(start_spinner "Etap 3: Skanowanie Portów (Nmap)" "${pids_stage3[@]}")
        for pid in "${pids_stage3[@]}"; do
            if ! wait "$pid"; then
                echo "${RED}Error in Nmap Scan with PID $pid.${NC}" >> "$ERROR_LOG"
            fi
        done
        kill "$spinner_pid" 2>/dev/null
    fi
    echo -ne "\r${GREEN}✓ Skanowanie portów zakończono!${NC}\n"
}

# Główna funkcja skanowania domeny
scan_domain() {
    # Ustaw globalne zmienne domeny na podstawie bieżącego celu
    domain=$1
    domain_part=$(echo "$domain" | cut -d':' -f1)
    port_part=$(echo "$domain" | grep -q ':' && echo "$domain" | cut -d':' -f2 || echo "")

    # Dynamiczne dostosowanie timeoutu na podstawie długości domeny
    local domain_len=${#domain_part}
    local base_timeout=$TIMEOUT # Zachowaj oryginalny timeout
    if (( domain_len > 20 )); then # Przykład: jeśli domena jest długa
        TIMEOUT=$(( base_timeout + (domain_len / 5) * 10 )) # Zwiększ timeout
        echo -e "${YELLOW}Długa domena wykryta. Timeout zwiększony do ${TIMEOUT}s.${NC}"
    else
        TIMEOUT=$base_timeout # Przywróć oryginalny timeout
    fi

    # Sprawdź, czy wyniki dla tej domeny już istnieją w katalogu wyjściowym
    # Używamy istnienia głównego pliku all_subdomains.txt jako wskaźnika
    if [ -s "$OUTPUT_DIR/all_subdomains.txt" ] && grep -q -E "^$domain_part$" "$OUTPUT_DIR/all_subdomains.txt"; then
        echo -e "${YELLOW}Wyniki dla domeny '$domain' prawdopodobnie już istnieją w '$OUTPUT_DIR'.${NC}"
        echo -e "${YELLOW}Czy chcesz pominąć skanowanie tej domeny? (y/n)${NC}"
        read -sn1 choice
        echo # Nowa linia po wyborze
        if [[ "$choice" == "y" || "$choice" == "Y" ]]; then
            echo -e "${YELLOW}Pominięto skanowanie dla '$domain'.${NC}"
            return # Wyjdź z funkcji scan_domain dla tej domeny
        else
            echo -e "${YELLOW}Kontynuuję skanowanie dla '$domain' (istniejące wyniki zostaną nadpisane w końcowej konsolidacji).${NC}"
            # Nie usuwamy plików tutaj za pomocą sed -i, ponieważ finalna konsolidacja w main()
            # zajmie się unikalnością i nadpisaniem.
        fi
    fi

    recon_stage "$domain"
    pre_scan_httpx_ports "$domain" # Nowy etap wstępnego skanowania portów
    crawl_stage "$domain"
    port_scan_stage "$domain" # Nowy etap skanowania portów

    # Skonsoliduj wyniki z plików tymczasowych do plików docelowych
    # Subdomeny
    sort -u "$TMPDIR/ffuf_subdomains.tmp" "$TMPDIR/gobuster_vhost.tmp" \
             "$TMPDIR/subfinder_subdomains.tmp" "$TMPDIR/amass_subdomains.tmp" \
             "$TMPDIR/crtsh_subdomains.tmp" 2>/dev/null >> "$OUTPUT_DIR/all_subdomains.txt"

    # Live hosty
    if [ -s "$TMPDIR/live_subdomains.tmp" ]; then # Sprawdź, czy plik istnieje i nie jest pusty
        cat "$TMPDIR/live_subdomains.tmp" >> "$OUTPUT_DIR/live_subdomains.txt"
    fi

    # Vhosty ze statusem 200 (z Gobuster)
    if [ -s "$TMPDIR/gobuster_vhost.tmp" ]; then # Sprawdź, czy plik istnieje i nie jest pusty
        # Wyjście Gobuster vhost zawiera "Found: subdomain.example.com (Status: 200)"
        grep "Found:" "$TMPDIR/gobuster_vhost.tmp" | grep -i "status: 200" | cut -d' ' -f2 | sort -u >> "$OUTPUT_DIR/vhost_status_200.txt"
    fi

    # Znalezione URL-e (Waybackurls, Katana, Hakrawler, Gau)
    sort -u "$TMPDIR/waybackurls_out.tmp" "$TMPDIR/katana_out.tmp" \
             "$TMPDIR/hakrawler_out.tmp" "$TMPDIR/gau_out.tmp" 2>/dev/null >> "$OUTPUT_DIR/found_urls.txt"

    # URL-e z parametrami (Paramspider)
    if [ -s "$TMPDIR/paramspider_out.tmp" ]; then # Sprawdź, czy plik istnieje i nie jest pusty
        cat "$TMPDIR/paramspider_out.tmp" | sort -u >> "$OUTPUT_DIR/urls_with_params.txt"
    fi

    # Wyniki Nuclei
    if [ -s "$TMPDIR/nuclei_out.tmp" ]; then
        cat "$TMPDIR/nuclei_out.tmp" | sort -u >> "$OUTPUT_DIR/nuclei_results.txt"
    fi
}

# Funkcja do generowania raportu JSON
generate_json_report() {
    local domain_for_report=$1 # Użyj tej zmiennej, aby uniknąć kolizji nazw
    local report_file="$OUTPUT_DIR/report.json"

    local all_subdomains_count=$(wc -l < "$OUTPUT_DIR/all_subdomains.txt" 2>/dev/null || echo 0)
    local live_subdomains_count=$(wc -l < "$OUTPUT_DIR/live_subdomains.txt" 2>/dev/null || echo 0)
    local vhost_200_count=$( [ -s "$OUTPUT_DIR/vhost_status_200.txt" ] && wc -l < "$OUTPUT_DIR/vhost_status_200.txt" 2>/dev/null || echo 0 )
    local found_urls_count=$( [ -s "$OUTPUT_DIR/found_urls.txt" ] && wc -l < "$OUTPUT_DIR/found_urls.txt" 2>/dev/null || echo 0 )
    local urls_with_params_count=$( [ -s "$OUTPUT_DIR/urls_with_params.txt" ] && wc -l < "$OUTPUT_DIR/urls_with_params.txt" 2>/dev/null || echo 0 )
    local nuclei_results_count=$( [ -s "$OUTPUT_DIR/nuclei_results.txt" ] && wc -l < "$OUTPUT_DIR/nuclei_results.txt" 2>/dev/null || echo 0 )


    local error_log_content=""
    if [ -s "$ERROR_LOG" ]; then
        # Odczytaj zawartość logu błędów i escapuj znaki specjalne dla JSON
        error_log_content=$(cat "$ERROR_LOG" | sed 's/"/\\"/g' | sed ':a;N;s/\n/\\n/g;ta')
    fi

    local selected_tools_json=""
    for i in "${!TOOLS[@]}"; do
        if [ ${SELECTED[i]} -eq 1 ]; then
            selected_tools_json+="\"${TOOLS[i]}\","
        fi
    done
    selected_tools_json="${selected_tools_json%,}" # Usuń końcowy przecinek

    # Znajdź indeks Nmap Scan dynamicznie
    local nmap_index=-1
    for idx in "${!TOOLS[@]}"; do
        if [[ "${TOOLS[$idx]}" == "Nmap Scan" ]]; then
            nmap_index=$idx
            break
        fi
    done

    local nmap_output_files_json=""
    if [ "$nmap_index" -ne -1 ] && [ ${SELECTED[$nmap_index]} -eq 1 ] && [ -f "$OUTPUT_DIR/${domain_part}_nmap.nmap" ]; then
        nmap_output_files_json="\"${domain_part}_nmap.nmap\", \"${domain_part}_nmap.xml\", \"${domain_part}_nmap.gnmap\""
    fi

    cat <<EOF > "$report_file"
{
  "date": "$(date)",
  "target": "$domain_for_report",
  "used_tools": [${selected_tools_json}, "Nuclei Scan", "Gau Scan"],
  "settings": {
    "rate_limit_mode": "$RATE_LIMIT_MODE",
    "threads": $THREADS,
    "timeout_seconds": $TIMEOUT,
    "delay_seconds": $DELAY_SECONDS,
    "random_user_agent_enabled": $RANDOM_USER_AGENT_ENABLED,
    "current_user_agent": "$CURRENT_USER_AGENT",
    "stealth_mode": $STEALTH_MODE,
    "nmap_port_range": "$NMAP_PORT_RANGE"
  },
  "results": {
    "all_subdomains_count": $all_subdomains_count,
    "live_subdomains_count": $live_subdomains_count,
    "vhost_status_200_count": $vhost_200_count,
    "found_urls_count": $found_urls_count,
    "urls_with_params_count": $urls_with_params_count,
    "nuclei_results_count": $nuclei_results_count
  },
  "files": {
    "all_subdomains": "$(basename "$OUTPUT_DIR/all_subdomains.txt")",
    "live_subdomains": "$(basename "$OUTPUT_DIR/live_subdomains.txt")",
    "vhost_status_200": "$( [ -s "$OUTPUT_DIR/vhost_status_200.txt" ] && basename "$OUTPUT_DIR/vhost_status_200.txt" || echo "" )",
    "found_urls": "$( [ -s "$OUTPUT_DIR/found_urls.txt" ] && basename "$OUTPUT_DIR/found_urls.txt" || echo "" )",
    "urls_with_params": "$( [ -s "$OUTPUT_DIR/urls_with_params.txt" ] && basename "$OUTPUT_DIR/urls_with_params.txt" || echo "" )",
    "nuclei_results": "$( [ -s "$OUTPUT_DIR/nuclei_results.txt" ] && basename "$OUTPUT_DIR/nuclei_results.txt" || echo "" )",
    "error_log": "$(basename "$ERROR_LOG")",
    "nmap_output_files": [${nmap_output_files_json}]
  },
  "error_log_content": "$error_log_content"
}
EOF
    echo -e "\n${GREEN}Raport JSON zapisano: $report_file${NC}"
}

main() {
    # Usuń wszelkie pozostałe tymczasowe katalogi z poprzednich uruchomień
    rm -rf /tmp/ShadowMap_* 2>/dev/null

    # Ustaw katalog tymczasowy i pułapkę na wyjście
    TMPDIR=$(mktemp -d -t ShadowMap_XXXXXX)
    trap 'rm -rf "$TMPDIR"; echo -e "${BLUE}Wyczyszczono katalog tymczasowy: $TMPDIR${NC}"' EXIT
    # Lepsza obsługa SIGINT
    trap 'kill $(jobs -p); echo -e "\n${RED}Przerwano przez użytkownika. Czyszczenie...${NC}"; exit 1' SIGINT

    # Domyślny katalog wyjściowy
    OUTPUT_DIR="./"

    # Usuń stary log błędów na początku i upewnij się, że plik logu błędów istnieje
    rm -f "$ERROR_LOG"
    touch "$ERROR_LOG"

    # Zmienne do przechowywania jawnie podanych wartości -t i -T
    local opt_threads_val=""
    local opt_timeout_val=""

    # Parsuj opcje wiersza poleceń
    while getopts "u:f:w:t:T:hQjo:rl:stealth" opt; do
        case $opt in
            u) URL=$(clean_domain "$OPTARG") ;;
            f) DOMAINS_FILE="$OPTARG" ;;
            w) WORDLIST="$OPTARG" ;;
            t) opt_threads_val="$OPTARG" ;; # Przechowaj wartość -t
            T) opt_timeout_val="$OPTARG" ;; # Przechowaj wartość -T
            h)
                clear
                print_title
                echo -e "${BLUE}Użycie:${NC} ${GREEN}$0${NC} [${YELLOW}OPCJE${NC}]"
                echo -e " Automatyczny zestaw narzędzi do rekonesansu domen."
                echo ""
                echo -e "${BLUE}Opcje:${NC}"
                echo -e " ${YELLOW}-u ${NC}${GREEN}<URL>${NC} Cel URL (np. ${YELLOW}example.com${NC}, ${YELLOW}sub.example.com${NC})"
                echo -e " ${YELLOW}-f ${NC}${GREEN}<PLIK>${NC} Plik zawierający listę domen (jedna domena na linię)"
                echo -e " ${YELLOW}-w ${NC}${GREEN}<LISTA_SŁÓW>${NC} Ścieżka do pliku listy słów (domyślnie: ${YELLOW}/usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt${NC})"
                echo -e " ${YELLOW}-t ${NC}${GREEN}<WĄTKI>${NC} Liczba wątków do użycia przez narzędzia (nadpisuje ustawienia ${YELLOW}--rl${NC})"
                echo -e " ${YELLOW}-T ${NC}${GREEN}<TIMEOUT>${NC} Timeout w sekundach dla żądań (nadpisuje ustawienia ${YELLOW}--rl${NC})"
                echo -e " ${YELLOW}-Q${NC} Włącz tryb cichy (pomija wyjście narzędzi do konsoli, tylko błędy do logu)"
                echo -e " ${YELLOW}-j${NC} Generuj raport JSON (oprócz domyślnego raportu Markdown)"
                echo -e " ${YELLOW}-o ${NC}${GREEN}<KATALOG>${NC} Określ katalog wyjściowy dla wyników (domyślnie: ${YELLOW}./${NC})"
                echo -e " ${YELLOW}-h${NC} Wyświetl ten komunikat pomocy i zakończ"
                echo ""
                echo -e "${BLUE}Opcje limitowania zapytań (${YELLOW}--rl${NC}):${NC}"
                echo -e " Pozwala na kontrolę szybkości skanowania. Wybierz jeden z predefiniowanych trybów"
                echo -e " lub podaj niestandardową liczbę wątków."
                echo -e " ${YELLOW}--rl=${NC}${GREEN}LOW${NC} Tryb niskiego obciążenia:"
                echo -e " - Wątki: ${GREEN}5${NC}"
                echo -e " - Timeout: ${GREEN}60s${NC}"
                echo -e " - Opóźnienie: ${GREEN}2s${NC} między żądaniami"
                echo -e " - User-Agent: ${GREEN}Losowy${NC}"
                echo -e " ${YELLOW}--rl=${NC}${GREEN}MEDIUM${NC} Tryb umiarkowanego obciążenia (domyślny):"
                echo -e " - Wątki: ${GREEN}20${NC}"
                echo -e " - Timeout: ${GREEN}45s${NC}"
                echo -e " - Opóźnienie: ${GREEN}0.5s${NC} między żądaniami"
                echo -e " - User-Agent: ${RED}Domyślny${NC}"
                echo -e " ${YELLOW}--rl=${NC}${GREEN}HIGH${NC} Tryb wysokiego obciążenia:"
                echo -e " - Wątki: ${GREEN}40${NC}"
                echo -e " - Timeout: ${GREEN}30s${NC}"
                echo -e " - Opóźnienie: ${GREEN}0s${NC}"
                echo -e " - User-Agent: ${RED}Domyślny${NC}"
                echo -e " ${YELLOW}--rl=${NC}${GREEN}<liczba>${NC} Ustawia niestandardową liczbę wątków (np. ${YELLOW}--rl=15${NC})."
                echo -e " Pozostałe parametry (timeout, opóźnienie, UA) pozostają domyślne."
                echo ""
                echo -e "${BLUE}Tryb ukrycia (${YELLOW}--stealth${NC}):${NC}"
                echo -e " ${YELLOW}--stealth${NC} Automatycznie ustawia tryb limitowania na ${GREEN}LOW${NC},"
                echo -e " włącza opóźnienia i używa losowego User-Agenta."
                echo -e " Jest to równoznaczne z użyciem ${YELLOW}--rl=LOW${NC}."
                echo ""
                echo -e "${BLUE}Narzędzia zawsze aktywne:${NC}"
                echo -e " - ${GREEN}Nuclei Scan${NC} (skanowanie podatności)"
                echo -e " - ${GREEN}Gau Scan${NC} (zbieranie URL-i)"
                echo ""
                echo -e "${BLUE}Przykłady użycia:${NC}"
                echo -e " ${GREEN}$0 -u example.com${NC}"
                echo -e " ${GREEN}$0 -f domains.txt -j -o my_scan_results --rl=LOW${NC}"
                echo -e " ${GREEN}$0 -u test.com --stealth -Q${NC}"
                echo -e " ${GREEN}$0 -u target.net -t 10 -T 90${NC}"
                echo -e " ${GREEN}$0 -u example.org --rl=CUSTOM --threads=25${NC}"
                echo ""
                echo -e "${YELLOW}Wskazówka:${NC} Po uruchomieniu skryptu, możesz interaktywnie zmieniać wybrane narzędzia i opcje."
                exit 0
                ;;
            Q) QUIET_MODE=1 ;;
            j) JSON_OUTPUT=1 ;;
            o) OUTPUT_DIR="$OPTARG"
                mkdir -p "$OUTPUT_DIR" || { echo -e "${RED}Błąd: Nie można utworzyć katalogu wyjściowego: $OUTPUT_DIR${NC}" >&2; exit 1; }
                ;;
            rl)
                RATE_LIMIT_MODE=$(echo "$OPTARG" | tr '[:lower:]' '[:upper:]')
                if [[ "$RATE_LIMIT_MODE" =~ ^[0-9]+$ ]]; then
                    CUSTOM_RATE_LIMIT_THREADS="$RATE_LIMIT_MODE"
                    RATE_LIMIT_MODE="CUSTOM"
                fi
                ;;
            stealth)
                STEALTH_MODE=1
                ;;
            *)
                echo -e "${RED}Nieprawidłowa opcja: -$OPTARG${NC}" >&2
                echo "Użycie: $0 [-u URL] [-f PLIK] [-t WĄTKI] [-T TIMEOUT] [-Q] [-j] [-o KATALOG_WYJŚCIOWY] [--rl=TRYB|<liczba>] [--stealth]" >&2
                exit 1
                ;;
        esac
    done

    # Ustaw początkowe opcje limitowania zapytań na podstawie trybu/ukrycia
    set_rate_limit_options

    # Nadpisz THREADS i TIMEOUT, jeśli zostały jawnie podane za pomocą -t lub -T
    if [ -n "$opt_threads_val" ]; then
        THREADS="$opt_threads_val"
        echo -e "${YELLOW}Wątki ustawione ręcznie na: ${THREADS}${NC}"
    fi
    if [ -n "$opt_timeout_val" ]; then
        TIMEOUT="$opt_timeout_val"
        echo -e "${YELLOW}Timeout ustawiony ręcznie na: ${TIMEOUT}s${NC}"
    fi

    # Walidacja wątków
    if (( THREADS > 100 )); then
        echo -e "${YELLOW}Ostrzeżenie: Duża liczba wątków (${THREADS}) może spowodować niestabilność lub blokowanie!${NC}"
    fi

    # Walidacja
    [ -z "$URL" ] && [ -z "$DOMAINS_FILE" ] && { echo -e "${RED}Błąd: Podaj domenę (-u) lub plik domen (-f)${NC}" >&2; exit 1; }
    [ -n "$DOMAINS_FILE" ] && [ ! -f "$DOMAINS_FILE" ] && { echo -e "${RED}Błąd: Plik domen nie znaleziono: $DOMAINS_FILE${NC}" >&2; exit 1; }
    
    # Sprawdź i pobierz wordlist, jeśli nie istnieje
    if [ ! -f "$WORDLIST" ]; then
        download_default_wordlist
    fi

    check_dependencies
    show_menu # Pokaż menu po ostatecznym ustawieniu opcji

    # Przetwarzanie celów
    if [ -n "$DOMAINS_FILE" ]; then
        while IFS= read -r domain_entry || [ -n "$domain_entry" ]; do
            domain_to_process=$(clean_domain "$domain_entry")
            if validate_domain "$domain_to_process"; then
                scan_domain "$domain_to_process"
            else
                echo -e "${RED}Pominięto nieprawidłową domenę: $domain_to_process${NC}" >&2
            fi
        done < "$DOMAINS_FILE"
    else
        if validate_domain "$URL"; then
            scan_domain "$URL"
        else
            echo -e "${RED}Pominięto nieprawidłową domenę: $URL${NC}" >&2
        fi
    fi

    # Końcowa konsolidacja i sortowanie głównych plików wyjściowych
    # Te operacje są idempotentne i bezpieczne do uruchomienia na końcu,
    # nawet jeśli niektóre domeny zostały pominięte lub nadpisane.
    sort -u "$OUTPUT_DIR/all_subdomains.txt" -o "$OUTPUT_DIR/all_subdomains.txt" 2>/dev/null
    sort -u "$OUTPUT_DIR/found_urls.txt" -o "$OUTPUT_DIR/found_urls.txt" 2>/dev/null
    sort -u "$OUTPUT_DIR/urls_with_params.txt" -o "$OUTPUT_DIR/urls_with_params.txt" 2>/dev/null
    sort -u "$OUTPUT_DIR/vhost_status_200.txt" -o "$OUTPUT_DIR/vhost_status_200.txt" 2>/dev/null
    sort -u "$OUTPUT_DIR/live_subdomains.txt" -o "$OUTPUT_DIR/live_subdomains.txt" 2>/dev/null
    sort -u "$OUTPUT_DIR/nuclei_results.txt" -o "$OUTPUT_DIR/nuclei_results.txt" 2>/dev/null


    echo -e "\n${BLUE}Unikalne subdomeny: ${GREEN}$(wc -l < "$OUTPUT_DIR/all_subdomains.txt" 2>/dev/null || echo 0)${NC}"
    if [ ${SELECTED[1]} -eq 1 ] && [ -s "$OUTPUT_DIR/vhost_status_200.txt" ]; then
        echo -e "${BLUE}Vhosty ze statusem 200: ${GREEN}$(wc -l < "$OUTPUT_DIR/vhost_status_200.txt" 2>/dev/null || echo 0)${NC}"
    fi
    echo -e "${GREEN}Live hosty: $(wc -l < "$OUTPUT_DIR/live_subdomains.txt" 2>/dev/null || echo 0)${NC}"
    # Zaktualizowano indeksy SELECTED dla found_urls, ponieważ Nuclei i Gau są teraz zawsze aktywne
    if [ -s "$OUTPUT_DIR/found_urls.txt" ]; then # Sprawdź, czy plik istnieje i nie jest pusty
        echo -e "${BLUE}Wszystkie znalezione URL-e (Waybackurls, Katana, Hakrawler, Gau): ${GREEN}$(wc -l < "$OUTPUT_DIR/found_urls.txt" 2>/dev/null || echo 0)${NC}"
    fi
    if [ ${SELECTED[7]} -eq 1 ]; then # Paramspider jest na indeksie 7
        echo -e "${BLUE}URL-e z parametrami (Paramspider): ${GREEN}$(wc -l < "$OUTPUT_DIR/urls_with_params.txt" 2>/dev/null || echo 0)${NC}"
    fi
    # Nuclei jest zawsze aktywne
    if [ -s "$OUTPUT_DIR/nuclei_results.txt" ]; then
        echo -e "${BLUE}Wyniki Nuclei: ${GREEN}$(wc -l < "$OUTPUT_DIR/nuclei_results.txt" 2>/dev/null || echo 0)${NC}"
    fi

    # Generuj raport Markdown
    {
        echo "# Raport Subdomen"
        echo "**Data**: $(date)"
        echo "**Cel(e)**: ${URL:-$DOMAINS_FILE}"
        echo "**Użyte narzędzia**:"
        for i in "${!TOOLS[@]}"; do
            if [ ${SELECTED[i]} -eq 1 ]; then
                echo "- ${TOOLS[i]}"
            fi
        done
        echo "- Nuclei Scan (zawsze aktywny)"
        echo "- Gau Scan (zawsze aktywny)"
        echo "## Ustawienia skanowania"
        echo "- **Tryb limitowania zapytań**: $RATE_LIMIT_MODE"
        echo "- **Wątki**: $THREADS"
        echo "- **Timeout**: ${TIMEOUT}s"
        echo "- **Opóźnienie**: ${DELAY_SECONDS}s"
        echo "- **Losowy User-Agent**: $( [ "$RANDOM_USER_AGENT_ENABLED" -eq 1 ] && echo "Tak" || echo "Nie" )"
        if [ -n "$CURRENT_USER_AGENT" ]; then
            echo "- **Użyty User-Agent**: $CURRENT_USER_AGENT"
        fi
        echo "- **Tryb ukrycia**: $( [ "$STEALTH_MODE" -eq 1 ] && echo "Włączony" || echo "Wyłączony" )"
        if [ -n "$NMAP_PORT_RANGE" ]; then
            echo "- **Zakres portów Nmap**: $NMAP_PORT_RANGE"
        fi
        echo "## Wyniki"
        echo "### Wszystkie Subdomeny"
        echo "Liczba: $(wc -l < "$OUTPUT_DIR/all_subdomains.txt" 2>/dev/null || echo 0)"
        echo "### Live Hosty"
        echo "Liczba: $(wc -l < "$OUTPUT_DIR/live_subdomains.txt" 2>/dev/null || echo 0)"
        if [ ${SELECTED[1]} -eq 1 ] && [ -s "$OUTPUT_DIR/vhost_status_200.txt" ]; then
            echo "### Vhosty ze statusem 200"
            echo "Liczba: $(wc -l < "$OUTPUT_DIR/vhost_status_200.txt" 2>/dev/null || echo 0)"
        fi
        if [ -s "$OUTPUT_DIR/found_urls.txt" ]; then # Zaktualizowano warunek
            echo "### Wszystkie Znalezione URL-e"
            echo "Liczba: $(wc -l < "$OUTPUT_DIR/found_urls.txt" 2>/dev/null || echo 0)"
        fi
        if [ ${SELECTED[7]} -eq 1 ]; then
            echo "### URL-e z Parametrami"
            echo "Liczba: $(wc -l < "$OUTPUT_DIR/urls_with_params.txt" 2>/dev/null || echo 0)"
        fi
        echo "### Wyniki Nuclei"
        echo "Liczba: $(wc -l < "$OUTPUT_DIR/nuclei_results.txt" 2>/dev/null || echo 0)"
        if [ -s "$OUTPUT_DIR/nuclei_results.txt" ]; then
            echo "Szczegółowe wyniki Nuclei można znaleźć w pliku: ${OUTPUT_DIR}/nuclei_results.txt"
        fi

        # Znajdź indeks Nmap Scan dynamicznie
        local nmap_index=-1
        for idx in "${!TOOLS[@]}"; do
            if [[ "${TOOLS[$idx]}" == "Nmap Scan" ]]; then
                nmap_index=$idx
                break
            fi
        done

        if [ "$nmap_index" -ne -1 ] && [ ${SELECTED[$nmap_index]} -eq 1 ] && [ -f "$OUTPUT_DIR/${domain_part}_nmap.nmap" ]; then
            echo "### Wyniki skanowania Nmap"
            echo "Szczegółowe wyniki Nmap można znaleźć w następujących plikach:"
            echo "- ${domain_part}_nmap.nmap"
            echo "- ${domain_part}_nmap.xml"
            echo "- ${domain_part}_nmap.gnmap"
        fi

        # Dodaj sekcję logu błędów do raportu
        if [ -s "$ERROR_LOG" ]; then # Tylko jeśli plik nie jest pusty
            echo "## Logi błędów"
            echo "Poniżej znajdują się błędy napotkane podczas wykonywania narzędzi. Sprawdź '$ERROR_LOG' dla pełnych szczegółów."
            echo "\`\`\`"
            cat "$ERROR_LOG"
            echo "\`\`\`"
        fi
    } > "$OUTPUT_DIR/report.md"
    echo -e "\n${GREEN}Raport zapisano: $OUTPUT_DIR/report.md${NC}"
    echo -e "${BLUE}Wyniki:${NC}"
    echo -e "• Wszystkie subdomeny: $OUTPUT_DIR/all_subdomains.txt"
    echo -e "• Live hosty: $OUTPUT_DIR/live_subdomains.txt"
    if [ ${SELECTED[1]} -eq 1 ] && [ -s "$OUTPUT_DIR/vhost_status_200.txt" ]; then
        echo -e "• Vhosty: $OUTPUT_DIR/vhost_status_200.txt"
    fi
    if [ -s "$OUTPUT_DIR/found_urls.txt" ]; then # Zaktualizowano warunek
        echo -e "• Wszystkie znalezione URL-e (Waybackurls, Katana, Hakrawler, Gau): $OUTPUT_DIR/found_urls.txt"
    fi
    if [ ${SELECTED[7]} -eq 1 ]; then
        echo -e "• URL-e z parametrami: $OUTPUT_DIR/urls_with_params.txt"
    fi
    echo -e "• Wyniki Nuclei: $OUTPUT_DIR/nuclei_results.txt"
    if [ "$nmap_index" -ne -1 ] && [ ${SELECTED[$nmap_index]} -eq 1 ] && [ -f "$OUTPUT_DIR/${domain_part}_nmap.nmap" ]; then
        echo -e "• Wyniki Nmap: ${domain_part}_nmap.nmap, ${domain_part}_nmap.xml, ${domain_part}_nmap.gnmap"
    fi
    echo -e "• Logi błędów: $ERROR_LOG"
    if [ "$JSON_OUTPUT" -eq 1 ]; then
        generate_json_report "${URL:-$(head -n 1 "$DOMAINS_FILE" 2>/dev/null || echo "N/A")}" # Użyj pierwszej domeny z pliku, jeśli plik jest podany
    fi
    
    # Statystyki wydajności
    add_time_report() {
        echo -e "\n[*] Czas wykonania: $SECONDS sekund"
    }
    trap add_time_report EXIT
}

main "$@"
